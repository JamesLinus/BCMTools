BCMTools_20130709 のみに存在: .README.txt.swp
BCMTools_20130709 のみに存在: .git
BCMTools_20130709 のみに存在: FileIO
diff -r BCMTools_20130417/Makefile.inc BCMTools_20130709/Makefile.inc
1,28c1,21
< 
< DEFINES = -DDEBUG
< 
< CXX = mpic++
< OPTIONS = $(DEFINES) -DTIMING -O3 -ftree-vectorize -g -Wall -Wno-sign-compare -Wunknown-pragmas -fopenmp
< 
< #CXX = mpiFCCpx
< #OPTIONS = $(DEFINES) -Xg -Kfast,openmp,ocl,optmsg=2 -Nsrc
< 
< 
< #可視化用出力を利用するには，次の設定も必要
< #  SILO_INC: Siloライブラリのインクルードファイルディレクトリ指定
< #  SILO_LIB: Siloライブラリのリンクオプション
< 
< #SILO_INC = -I$(HOME)/silo-4.8-bsd/include
< #SILO_LIB = -L$(HOME)/silo-4.8-bsd/lib -L$(HOME)/hdf5-1.8.9/hdf5/lib -lsiloh5 -lhdf5 -lz
< 
< #SILO_INC = -I$(HOME)/opt/include
< #SILO_LIB = -L$(HOME)/opt/lib -lsiloh5 -lhdf5 -lz
< 
< #SILO_INC = -I$(HOME)/FX10/include
< #SILO_LIB = -L$(HOME)/FX10/lib -lsiloh5 -lhdf5 -lz
< 
< #SILO_INC = -I$(HOME)/K/include
< #SILO_LIB = -L$(HOME)/K/lib -lsiloh5 -lhdf5 -lz
< 
< SILO_INC = 
< SILO_LIB = -lsiloh5 -lhdf5 -lz
---
> # For GCC
> CXX        = g++
> OPT_FLAGS  = -O3 
> OMP_FLAGS  = -fopenmp
> MPI_DIR    = /usr/lib/openmpi
> DEFINES    = -DDEBUG
> DEFINES   += -D_BLOCK_IS_LARGE_
> CFLAGS     = $(OPT_FLAGS) $(OMP_FLAGS) $(DEFINES) -I$(MPI_DIR)/include
> 
> # For Intel compiler
> CXX        = icpc
> OPT_FLAGS  = -O3 #-xAVX
> OMP_FLAGS  = -openmp
> MPI_DIR    = /usr/lib/openmpi
> DEFINES    = -DDEBUG
> DEFINES   += -D_BLOCK_IS_LARGE_
> CFLAGS     = $(OPT_FLAGS) $(OMP_FLAGS) $(DEFINES) -I$(MPI_DIR)/include
> 
> AR     = ar cru
> RANLIB = ranlib
> RM     = \rm -f
diff -r BCMTools_20130417/README.txt BCMTools_20130709/README.txt
0a1
> ==================
1a3
> ==================
8a11,26
> 
> 
> -----------
> Change logs
> -----------
> 
> * 2013/07/09 (jonishi@iis.u-tokyo.ac.jp)
> - examples/ParallelMeshGeneration を削除(TPlibバージョン不整合)
> 
> * 2013/04/17 (jonishi@iis.u-tokyo.ac.jp)
> - FileIO の追加
> - SolverTest の追加
> - Makefile.inc -> make_setting.{fx,gnu,ibm,intel} への変更
> - DataClass.list の廃止
> - データ同期方法の追加
> - その他（バグなど）
BCMTools_20130709 のみに存在: Utils
BCMTools_20130417 のみに存在: diff_20120916_20130417.txt
BCMTools_20130417 のみに存在: diff_20120916_20130417_summary.txt
BCMTools_20130709 のみに存在: diff_20130417.txt
BCMTools_20130709 のみに存在: diff_20130417_20130709.txt
BCMTools_20130417/examples のみに存在: FileIO
BCMTools_20130417/examples のみに存在: ParallelMeshGeneration
diff -r BCMTools_20130417/examples/ParametricDivider/Makefile BCMTools_20130709/examples/ParametricDivider/Makefile
4c4
< UTIL = ../util
---
> UTIL = ../../Utils
13c13
< CFLAGS = -I../../include -I$(UTIL)/include $(SILO_INC) $(OPTIONS)
---
> CFLAGS += -I../../include -I$(UTIL)/include $(SILO_INC) $(OPTIONS)
16c16
< LIBS = $(BCMLIB) $(SILO_LIB)
---
> LIBS = $(BCMLIB) $(SILO_LIB) -lmpi -lmpi_cxx -lsiloh5
diff -r BCMTools_20130417/examples/PolygonDivider/Makefile BCMTools_20130709/examples/PolygonDivider/Makefile
4c4
< UTIL = ../util
---
> UTIL = ../../Utils
5a6
> XML2LIB = /home/jonishi/MyLib/libxml2-2.7.8
14c15
< CFLAGS = -I../../include -I$(UTIL)/include $(SILO_INC) \
---
> CFLAGS += -I../../include -I$(UTIL)/include $(SILO_INC) -I$(XML2LIB)/include \
18c19
< LIBS = $(BCMLIB) $(SILO_LIB) -lPolylib -lxml2
---
> LIBS = $(BCMLIB) $(SILO_LIB) -L$(POLYLIB)/lib -L$(XML2LIB)/lib -lPolylib -lxml2 -lmpi -lmpi_cxx -lsiloh5
BCMTools_20130417/examples/Polylib_2_0_3_Rel のみに存在: lib
diff -r BCMTools_20130417/examples/Polylib_2_0_3_Rel/src/depend.inc BCMTools_20130709/examples/Polylib_2_0_3_Rel/src/depend.inc
8,26c8,9
<  ../include/groups/PolygonGroup.h /usr/include/libxml2/libxml/tree.h \
<  /usr/include/libxml2/libxml/xmlversion.h \
<  /usr/include/libxml2/libxml/xmlexports.h \
<  /usr/include/libxml2/libxml/xmlstring.h \
<  /usr/include/libxml2/libxml/xmlregexp.h \
<  /usr/include/libxml2/libxml/dict.h \
<  /usr/include/libxml2/libxml/xmlmemory.h \
<  /usr/include/libxml2/libxml/threads.h \
<  /usr/include/libxml2/libxml/globals.h \
<  /usr/include/libxml2/libxml/parser.h /usr/include/libxml2/libxml/hash.h \
<  /usr/include/libxml2/libxml/valid.h \
<  /usr/include/libxml2/libxml/xmlerror.h \
<  /usr/include/libxml2/libxml/list.h \
<  /usr/include/libxml2/libxml/xmlautomata.h \
<  /usr/include/libxml2/libxml/entities.h \
<  /usr/include/libxml2/libxml/encoding.h \
<  /usr/include/libxml2/libxml/xmlIO.h /usr/include/libxml2/libxml/SAX.h \
<  /usr/include/libxml2/libxml/xlink.h /usr/include/libxml2/libxml/SAX2.h \
<  ../include/polygons/Triangle.h ../include/groups/PolygonGroupFactory.h \
---
>  ../include/groups/PolygonGroup.h ../include/polygons/Triangle.h \
>  ../include/groups/PolygonGroupFactory.h \
43,60d25
<  /usr/include/libxml2/libxml/tree.h \
<  /usr/include/libxml2/libxml/xmlversion.h \
<  /usr/include/libxml2/libxml/xmlexports.h \
<  /usr/include/libxml2/libxml/xmlstring.h \
<  /usr/include/libxml2/libxml/xmlregexp.h \
<  /usr/include/libxml2/libxml/dict.h \
<  /usr/include/libxml2/libxml/xmlmemory.h \
<  /usr/include/libxml2/libxml/threads.h \
<  /usr/include/libxml2/libxml/globals.h \
<  /usr/include/libxml2/libxml/parser.h /usr/include/libxml2/libxml/hash.h \
<  /usr/include/libxml2/libxml/valid.h \
<  /usr/include/libxml2/libxml/xmlerror.h \
<  /usr/include/libxml2/libxml/list.h \
<  /usr/include/libxml2/libxml/xmlautomata.h \
<  /usr/include/libxml2/libxml/entities.h \
<  /usr/include/libxml2/libxml/encoding.h \
<  /usr/include/libxml2/libxml/xmlIO.h /usr/include/libxml2/libxml/SAX.h \
<  /usr/include/libxml2/libxml/xlink.h /usr/include/libxml2/libxml/SAX2.h \
66,83d30
<  /usr/include/libxml2/libxml/tree.h \
<  /usr/include/libxml2/libxml/xmlversion.h \
<  /usr/include/libxml2/libxml/xmlexports.h \
<  /usr/include/libxml2/libxml/xmlstring.h \
<  /usr/include/libxml2/libxml/xmlregexp.h \
<  /usr/include/libxml2/libxml/dict.h \
<  /usr/include/libxml2/libxml/xmlmemory.h \
<  /usr/include/libxml2/libxml/threads.h \
<  /usr/include/libxml2/libxml/globals.h \
<  /usr/include/libxml2/libxml/parser.h /usr/include/libxml2/libxml/hash.h \
<  /usr/include/libxml2/libxml/valid.h \
<  /usr/include/libxml2/libxml/xmlerror.h \
<  /usr/include/libxml2/libxml/list.h \
<  /usr/include/libxml2/libxml/xmlautomata.h \
<  /usr/include/libxml2/libxml/entities.h \
<  /usr/include/libxml2/libxml/encoding.h \
<  /usr/include/libxml2/libxml/xmlIO.h /usr/include/libxml2/libxml/SAX.h \
<  /usr/include/libxml2/libxml/xlink.h /usr/include/libxml2/libxml/SAX2.h \
94,126d40
< MPIPolylib.o: ../include/MPIPolylib.h /usr/local/openmpi/include/mpi.h \
<  ../include/Polylib.h ../include/polygons/Polygons.h \
<  ../include/polygons/VTree.h ../include/common/BBox.h \
<  ../include/common/Vec2.h ../include/common/Vec3.h \
<  ../include/common/vec3_func.h ../include/common/vec3f_func.h \
<  ../include/common/axis.h ../include/common/PolylibStat.h \
<  ../include/common/PolylibCommon.h ../include/common/tt.h \
<  ../include/polygons/TriMesh.h ../include/polygons/Triangle.h \
<  ../include/groups/PolygonGroup.h /usr/include/libxml2/libxml/tree.h \
<  /usr/include/libxml2/libxml/xmlversion.h \
<  /usr/include/libxml2/libxml/xmlexports.h \
<  /usr/include/libxml2/libxml/xmlstring.h \
<  /usr/include/libxml2/libxml/xmlregexp.h \
<  /usr/include/libxml2/libxml/dict.h \
<  /usr/include/libxml2/libxml/xmlmemory.h \
<  /usr/include/libxml2/libxml/threads.h \
<  /usr/include/libxml2/libxml/globals.h \
<  /usr/include/libxml2/libxml/parser.h /usr/include/libxml2/libxml/hash.h \
<  /usr/include/libxml2/libxml/valid.h \
<  /usr/include/libxml2/libxml/xmlerror.h \
<  /usr/include/libxml2/libxml/list.h \
<  /usr/include/libxml2/libxml/xmlautomata.h \
<  /usr/include/libxml2/libxml/entities.h \
<  /usr/include/libxml2/libxml/encoding.h \
<  /usr/include/libxml2/libxml/xmlIO.h /usr/include/libxml2/libxml/SAX.h \
<  /usr/include/libxml2/libxml/xlink.h /usr/include/libxml2/libxml/SAX2.h \
<  ../include/polygons/Triangle.h ../include/groups/PolygonGroupFactory.h \
<  ../include/file_io/PolylibConfig.h ../include/common/PolylibStat.h \
<  ../include/common/PolylibCommon.h ../include/common/BBox.h \
<  ../include/common/Vec3.h
< CMPIPolylib.o: ../include/c_lang/CMPIPolylib.h \
<  /usr/local/openmpi/include/mpi.h ../include/common/PolylibStat.h \
<  ../include/c_lang/CPolylib.h
diff -r BCMTools_20130417/examples/Polylib_2_0_3_Rel_search_nearest/src/Makefile BCMTools_20130709/examples/Polylib_2_0_3_Rel_search_nearest/src/Makefile
13c13,14
< MPI_DIR		= /usr/local/openmpi
---
> MPI_DIR		= /usr/lib/openmpi
> XML2_DIR  = /home/jonishi/MyLib/libxml2-2.7.8
28c29
< CFLAGS		= -O2 -Wall -I../include -I$(MPI_DIR)/include \
---
> CFLAGS		= -O2 -Wall -I../include -I$(MPI_DIR)/include -I$(XML2_DIR)/include \
diff -r BCMTools_20130417/examples/Polylib_2_0_3_Rel_search_nearest/src/depend.inc BCMTools_20130709/examples/Polylib_2_0_3_Rel_search_nearest/src/depend.inc
8,25c8,29
<  ../include/groups/PolygonGroup.h /usr/include/libxml2/libxml/tree.h \
<  /usr/include/libxml2/libxml/xmlversion.h \
<  /usr/include/libxml2/libxml/xmlexports.h \
<  /usr/include/libxml2/libxml/xmlstring.h \
<  /usr/include/libxml2/libxml/xmlregexp.h \
<  /usr/include/libxml2/libxml/dict.h \
<  /usr/include/libxml2/libxml/xmlmemory.h \
<  /usr/include/libxml2/libxml/threads.h \
<  /usr/include/libxml2/libxml/globals.h \
<  /usr/include/libxml2/libxml/parser.h /usr/include/libxml2/libxml/hash.h \
<  /usr/include/libxml2/libxml/valid.h \
<  /usr/include/libxml2/libxml/xmlerror.h \
<  /usr/include/libxml2/libxml/list.h \
<  /usr/include/libxml2/libxml/xmlautomata.h \
<  /usr/include/libxml2/libxml/entities.h \
<  /usr/include/libxml2/libxml/encoding.h \
<  /usr/include/libxml2/libxml/xmlIO.h /usr/include/libxml2/libxml/SAX.h \
<  /usr/include/libxml2/libxml/xlink.h /usr/include/libxml2/libxml/SAX2.h \
---
>  ../include/groups/PolygonGroup.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/tree.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlversion.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlexports.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlstring.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlregexp.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/dict.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlmemory.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/threads.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/globals.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/parser.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/hash.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/valid.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlerror.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/list.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlautomata.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/entities.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/encoding.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlIO.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/SAX.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xlink.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/SAX2.h \
43,60c47,67
<  /usr/include/libxml2/libxml/tree.h \
<  /usr/include/libxml2/libxml/xmlversion.h \
<  /usr/include/libxml2/libxml/xmlexports.h \
<  /usr/include/libxml2/libxml/xmlstring.h \
<  /usr/include/libxml2/libxml/xmlregexp.h \
<  /usr/include/libxml2/libxml/dict.h \
<  /usr/include/libxml2/libxml/xmlmemory.h \
<  /usr/include/libxml2/libxml/threads.h \
<  /usr/include/libxml2/libxml/globals.h \
<  /usr/include/libxml2/libxml/parser.h /usr/include/libxml2/libxml/hash.h \
<  /usr/include/libxml2/libxml/valid.h \
<  /usr/include/libxml2/libxml/xmlerror.h \
<  /usr/include/libxml2/libxml/list.h \
<  /usr/include/libxml2/libxml/xmlautomata.h \
<  /usr/include/libxml2/libxml/entities.h \
<  /usr/include/libxml2/libxml/encoding.h \
<  /usr/include/libxml2/libxml/xmlIO.h /usr/include/libxml2/libxml/SAX.h \
<  /usr/include/libxml2/libxml/xlink.h /usr/include/libxml2/libxml/SAX2.h \
---
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/tree.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlversion.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlexports.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlstring.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlregexp.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/dict.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlmemory.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/threads.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/globals.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/parser.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/hash.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/valid.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlerror.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/list.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlautomata.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/entities.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/encoding.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlIO.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/SAX.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xlink.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/SAX2.h \
66,83c73,93
<  /usr/include/libxml2/libxml/tree.h \
<  /usr/include/libxml2/libxml/xmlversion.h \
<  /usr/include/libxml2/libxml/xmlexports.h \
<  /usr/include/libxml2/libxml/xmlstring.h \
<  /usr/include/libxml2/libxml/xmlregexp.h \
<  /usr/include/libxml2/libxml/dict.h \
<  /usr/include/libxml2/libxml/xmlmemory.h \
<  /usr/include/libxml2/libxml/threads.h \
<  /usr/include/libxml2/libxml/globals.h \
<  /usr/include/libxml2/libxml/parser.h /usr/include/libxml2/libxml/hash.h \
<  /usr/include/libxml2/libxml/valid.h \
<  /usr/include/libxml2/libxml/xmlerror.h \
<  /usr/include/libxml2/libxml/list.h \
<  /usr/include/libxml2/libxml/xmlautomata.h \
<  /usr/include/libxml2/libxml/entities.h \
<  /usr/include/libxml2/libxml/encoding.h \
<  /usr/include/libxml2/libxml/xmlIO.h /usr/include/libxml2/libxml/SAX.h \
<  /usr/include/libxml2/libxml/xlink.h /usr/include/libxml2/libxml/SAX2.h \
---
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/tree.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlversion.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlexports.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlstring.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlregexp.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/dict.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlmemory.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/threads.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/globals.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/parser.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/hash.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/valid.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlerror.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/list.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlautomata.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/entities.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/encoding.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlIO.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/SAX.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xlink.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/SAX2.h \
94c104
< MPIPolylib.o: ../include/MPIPolylib.h /usr/local/openmpi/include/mpi.h \
---
> MPIPolylib.o: ../include/MPIPolylib.h /usr/lib/openmpi/include/mpi.h \
102,119c112,133
<  ../include/groups/PolygonGroup.h /usr/include/libxml2/libxml/tree.h \
<  /usr/include/libxml2/libxml/xmlversion.h \
<  /usr/include/libxml2/libxml/xmlexports.h \
<  /usr/include/libxml2/libxml/xmlstring.h \
<  /usr/include/libxml2/libxml/xmlregexp.h \
<  /usr/include/libxml2/libxml/dict.h \
<  /usr/include/libxml2/libxml/xmlmemory.h \
<  /usr/include/libxml2/libxml/threads.h \
<  /usr/include/libxml2/libxml/globals.h \
<  /usr/include/libxml2/libxml/parser.h /usr/include/libxml2/libxml/hash.h \
<  /usr/include/libxml2/libxml/valid.h \
<  /usr/include/libxml2/libxml/xmlerror.h \
<  /usr/include/libxml2/libxml/list.h \
<  /usr/include/libxml2/libxml/xmlautomata.h \
<  /usr/include/libxml2/libxml/entities.h \
<  /usr/include/libxml2/libxml/encoding.h \
<  /usr/include/libxml2/libxml/xmlIO.h /usr/include/libxml2/libxml/SAX.h \
<  /usr/include/libxml2/libxml/xlink.h /usr/include/libxml2/libxml/SAX2.h \
---
>  ../include/groups/PolygonGroup.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/tree.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlversion.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlexports.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlstring.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlregexp.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/dict.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlmemory.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/threads.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/globals.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/parser.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/hash.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/valid.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlerror.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/list.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlautomata.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/entities.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/encoding.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xmlIO.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/SAX.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/xlink.h \
>  /home/jonishi/MyLib/libxml2-2.7.8/include/libxml/SAX2.h \
125c139
<  /usr/local/openmpi/include/mpi.h ../include/common/PolylibStat.h \
---
>  /usr/lib/openmpi/include/mpi.h ../include/common/PolylibStat.h \
BCMTools_20130709/examples/STL_DATA のみに存在: micra-m.stl
BCMTools_20130709/examples/STL_DATA のみに存在: sphere-l8.stl
BCMTools_20130417/examples/STL_DATA のみに存在: sphere2.stl
BCMTools_20130417/examples/SolverTest のみに存在: BCMFileSaver.o
BCMTools_20130417/examples/SolverTest のみに存在: BCMOctree.o
BCMTools_20130417/examples/SolverTest のみに存在: BCMPolylib.o
BCMTools_20130417/examples/SolverTest のみに存在: BitVoxel.o
diff -r BCMTools_20130417/examples/SolverTest/BlockScalar3D.cpp BCMTools_20130709/examples/SolverTest/BlockScalar3D.cpp
2a3,29
> #include "gv.h"
> 
> template <>
> void BlockScalar3D<real>::ImposeBlockBoundaryCondition_X_M_POISEUILLE_U() {
> 	::Vec3r c = g_pconf->boundaryValuePoiseuilleCenter;
> 	real center[3] = {c.x, c.y, c.z};
> 	bc_x3_poiseuille_u_(this->blockData, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), center, this->origin, this->blockSize, this->cellSize);
> }
> template <>
> void BlockScalar3D<real>::ImposeBlockBoundaryCondition_Aw_POISEUILLE_U(real* Ap, real* Aw, real* Ae, real* b) {
> 	::Vec3r c = g_pconf->boundaryValuePoiseuilleCenter;
> 	real center[3] = {c.x, c.y, c.z};
> 	bc_aw_poiseuille_u_(Ap, Aw, b, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), center, this->origin, this->blockSize, this->cellSize);
> }
> template <>
> void BlockScalar3D<real>::ImposeBlockBoundaryCondition_X_M_POISEUILLE_P() {
> 	::Vec3r c = g_pconf->boundaryValuePoiseuilleCenter;
> 	real center[3] = {c.x, c.y, c.z};
> 	bc_x3_poiseuille_p_(this->blockData, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), center, this->origin, this->blockSize, this->cellSize);
> }
> template <>
> void BlockScalar3D<real>::ImposeBlockBoundaryCondition_Aw_POISEUILLE_P(real* Ap, real* Aw, real* Ae, real* b) {
> 	::Vec3r c = g_pconf->boundaryValuePoiseuilleCenter;
> 	real center[3] = {c.x, c.y, c.z};
> 	bc_aw_poiseuille_p_(Ap, Aw, b, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), center, this->origin, this->blockSize, this->cellSize);
> }
> 
diff -r BCMTools_20130417/examples/SolverTest/BlockScalar3D.h BCMTools_20130709/examples/SolverTest/BlockScalar3D.h
324c324
< 		bc_x3_poiseuille_u_(this->blockData, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), this->origin, this->blockSize, this->cellSize);
---
> //		bc_x3_poiseuille_u_(this->blockData, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), this->origin, this->blockSize, this->cellSize);
327c327
< 		bc_aw_poiseuille_u_(Ap, Aw, b, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), this->origin, this->blockSize, this->cellSize);
---
> //		bc_aw_poiseuille_u_(Ap, Aw, b, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), this->origin, this->blockSize, this->cellSize);
329d328
< 
331c330
< 		bc_x3_poiseuille_p_(this->blockData, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), this->origin, this->blockSize, this->cellSize);
---
> //		bc_x3_poiseuille_p_(this->blockData, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), this->origin, this->blockSize, this->cellSize);
334c333
< 		bc_aw_poiseuille_p_(Ap, Aw, b, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), this->origin, this->blockSize, this->cellSize);
---
> //		bc_aw_poiseuille_p_(Ap, Aw, b, &(this->blockBoundaryValue[X_M]), this->size, (int*)&(this->vc), this->origin, this->blockSize, this->cellSize);
338a338,347
> void BlockScalar3D<real>::ImposeBlockBoundaryCondition_X_M_POISEUILLE_U();
> template <>
> void BlockScalar3D<real>::ImposeBlockBoundaryCondition_Aw_POISEUILLE_U(real* Ap, real* Aw, real* Ae, real* b);
> template <>
> void BlockScalar3D<real>::ImposeBlockBoundaryCondition_X_M_POISEUILLE_P();
> template <>
> void BlockScalar3D<real>::ImposeBlockBoundaryCondition_Aw_POISEUILLE_P(real* Ap, real* Aw, real* Ae, real* b);
> 
> 
> template <>
391d399
< 
404d411
< 
422d428
< 
BCMTools_20130417/examples/SolverTest のみに存在: BlockScalar3D.o
diff -r BCMTools_20130417/examples/SolverTest/Config.h BCMTools_20130709/examples/SolverTest/Config.h
37a38,39
> 	string operatorname;
> 
41a44,46
> 	bool periodicX;
> 	bool periodicY;
> 	bool periodicZ;
83a89
> 	bool bHeat;
96a103,108
> 	double gx;
> 	double gy;
> 	double gz;
> 	double uxs0;
> 	double uys0;
> 	double uzs0;
114a127,129
> 	bool holefilling;
> 	bool holefilling2;
> 	bool masking;
121a137
> 	bool PLOT3DSave;
187a204,205
> 	Vec3r boundaryValuePoiseuilleCenter;
> 
188a207
> 	bool BenchMode;
192a212,213
> 		operatorname = read<string>("OperatorName", "v(^_^)v");
> 
197a219,222
> 		periodicX = read<bool>("PeriodicX", false);
> 		periodicY = read<bool>("PeriodicY", false);
> 		periodicZ = read<bool>("PeriodicZ", false);
> 
240a266
> 		bHeat     = read<bool>("HeatProblem", true);
260a287,292
> 		gx    = read<double>("gx", 0.0);
> 		gy    = read<double>("gy", 0.0);
> 		gz    = read<double>("gz", 0.0);
> 		uxs0  = read<double>("uxs0", 0.0);
> 		uys0  = read<double>("uys0", 0.0);
> 		uzs0  = read<double>("uzs0", 0.0);
275a308,310
> 		holefilling    = read<bool>("holefilling", true);
> 		holefilling2   = read<bool>("holefilling2", true);
> 		masking        = read<bool>("masking", true);
283a319
> 		PLOT3DSave     = read<bool>("PLOT3DSave", false);
349a386,387
> 		boundaryValuePoiseuilleCenter = read<Vec3r>("boundaryValuePoiseuilleCenter", Vec3r(0.0, 0.0, 0.0));
> 
350a389
> 		BenchMode          = read<bool>("BenchMode", false);
BCMTools_20130417/examples/SolverTest のみに存在: ConfigBase.o
BCMTools_20130417/examples/SolverTest のみに存在: ConfigFile.o
BCMTools_20130417/examples/SolverTest のみに存在: ErrorUtil.o
BCMTools_20130417/examples/SolverTest のみに存在: FileSystemUtil.o
diff -r BCMTools_20130417/examples/SolverTest/ILS3D.h BCMTools_20130709/examples/SolverTest/ILS3D.h
12,15c12,13
< 
< #ifdef __K_FAPP
< #include <fj_tool/fapp.h>
< #endif
---
> #include "comm.h"
> #include "PM.h"
63a62
> PM_Start(tm_JacobiSmoother, 0, 0, true);
65,67c64,72
< #ifdef __K_FAPP
< fapp_start("jacobi_smoother", 0, 0);
< #endif 
---
> 		int NB = blockManager.getNumBlock();
> 		BlockBase* block0 = blockManager.getBlock(0);
> 		::Vec3i size = block0->getSize();
> 		int NX = size.x;
> 		int NY = size.y;
> 		int NZ = size.z;
> 		int sz[3] = {size.x, size.y, size.z};
> 
> PM_Start(tm_JacobiSmoother_Calc, 0, 0, true);
70,73d74
< 			::Vec3i blockSize = block->getSize();
< 			::Vec3r cellSize  = block->getCellSize();
< 			int sz[3] = {blockSize.x, blockSize.y, blockSize.z};
< 
93,105c94
< #ifdef __K_FAPP
< fapp_stop("jacobi_smoother", 0, 0);
< #endif
< 
< #ifdef _LARGE_BLOCK_
< #else
< #pragma omp parallel for
< #endif
< 		for (int n=0; n<blockManager.getNumBlock(); ++n) {
< 			BlockBase* block = blockManager.getBlock(n);
< 			::Vec3i blockSize = block->getSize();
< 			::Vec3r cellSize  = block->getCellSize();
< 			int sz[3] = {blockSize.x, blockSize.y, blockSize.z};
---
> PM_Stop(tm_JacobiSmoother_Calc, 0, 0, 16.0*NX*NY*NZ, NB);
107,117c96,98
< 			real* x  = plsx ->GetBlockData(block);
< 			real* Ap = plsAp->GetBlockData(block);
< 			real* Aw = plsAw->GetBlockData(block);
< 			real* Ae = plsAe->GetBlockData(block);
< 			real* As = plsAs->GetBlockData(block);
< 			real* An = plsAn->GetBlockData(block);
< 			real* Ab = plsAb->GetBlockData(block);
< 			real* At = plsAt->GetBlockData(block);
< 			real* b  = plsb ->GetBlockData(block);
< 			real* x0 = plsx0->GetBlockData(block);
< 			real pomega = omega;
---
> PM_Start(tm_JacobiSmoother_Swap, 0, 0, true);
> 		LSSwap(*plsx, *plsx0);
> PM_Stop(tm_JacobiSmoother_Swap);
119,120c100
< 			copy_(x, x0, sz, &vc);
< 		}
---
> PM_Start(tm_JacobiSmoother_Comm, 0, 0, true);
122,173c102
< 	}
< 
< 	void Jacobi_Smoother_Mask(
< 						BlockManager& blockManager,
< 						LocalScalar3D<real>* plsx,
< 						LocalScalar3D<real>* plsAp,
< 						LocalScalar3D<real>* plsAw,
< 						LocalScalar3D<real>* plsAe,
< 						LocalScalar3D<real>* plsAs,
< 						LocalScalar3D<real>* plsAn,
< 						LocalScalar3D<real>* plsAb,
< 						LocalScalar3D<real>* plsAt,
< 						LocalScalar3D<real>* plsb,
< 						LocalScalar3D<real>* plsx0,
< 						LocalScalar3D<int>* plsMaskId,
< 						real omega) {
< 		int vc = plsx->GetVC();
< 
< #ifdef __K_FAPP
< fapp_start("jacobi_smoother_mask", 0, 0);
< #endif 
< #pragma omp parallel for
< 		for (int n=0; n<blockManager.getNumBlock(); ++n) {
< 			BlockBase* block = blockManager.getBlock(n);
< 			::Vec3i blockSize = block->getSize();
< 			::Vec3r cellSize  = block->getCellSize();
< 			int sz[3] = {blockSize.x, blockSize.y, blockSize.z};
< 
< 			real* x  = plsx ->GetBlockData(block);
< 			real* Ap = plsAp->GetBlockData(block);
< 			real* Aw = plsAw->GetBlockData(block);
< 			real* Ae = plsAe->GetBlockData(block);
< 			real* As = plsAs->GetBlockData(block);
< 			real* An = plsAn->GetBlockData(block);
< 			real* Ab = plsAb->GetBlockData(block);
< 			real* At = plsAt->GetBlockData(block);
< 			real* b  = plsb ->GetBlockData(block);
< 			real* x0 = plsx0->GetBlockData(block);
< 			int* mask = plsMaskId->GetBlockData(block);
< 			real pomega = omega;
< 
< 			jacobi_smoother_mask_(
< 							x0, x,
< 							Ap, Aw, Ae, As, An, Ab, At,
< 							b,
< 							mask,
< 							&pomega,
< 							sz, &vc);
< 		}
< #ifdef __K_FAPP
< fapp_stop("jacobi_smoother_mask", 0, 0);
< #endif
---
> PM_Stop(tm_JacobiSmoother_Comm);
175,200c104
< #ifdef _LARGE_BLOCK_
< #else
< #pragma omp parallel for
< #endif
< 		for (int n=0; n<blockManager.getNumBlock(); ++n) {
< 			BlockBase* block = blockManager.getBlock(n);
< 			::Vec3i blockSize = block->getSize();
< 			::Vec3r cellSize  = block->getCellSize();
< 			int sz[3] = {blockSize.x, blockSize.y, blockSize.z};
< 
< 			real* x  = plsx ->GetBlockData(block);
< 			real* Ap = plsAp->GetBlockData(block);
< 			real* Aw = plsAw->GetBlockData(block);
< 			real* Ae = plsAe->GetBlockData(block);
< 			real* As = plsAs->GetBlockData(block);
< 			real* An = plsAn->GetBlockData(block);
< 			real* Ab = plsAb->GetBlockData(block);
< 			real* At = plsAt->GetBlockData(block);
< 			real* b  = plsb ->GetBlockData(block);
< 			real* x0 = plsx0->GetBlockData(block);
< 			real pomega = omega;
< 
< 			copy_(x, x0, sz, &vc);
< 		}
< 
< 		plsx->ImposeBoundaryCondition(blockManager);
---
> PM_Stop(tm_JacobiSmoother);
203d106
< 
216c119
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
244d146
< 
258c160
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
302c204
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
336a239,241
> 		allreduce_(&rr_global, &rr_local);
> /*
> #ifdef _REAL_IS_DOUBLE_		
337a243,246
> #else
> 		comm.Allreduce(&rr_local, &rr_global, 1, MPI_FLOAT, MPI_SUM);
> #endif
> */
349c258
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
370a280,282
> 		allreduce_(&xy_global, &xy_local);
> /*
> #ifdef _REAL_IS_DOUBLE_		
371a284,287
> #else
> 		comm.Allreduce(&xy_local, &xy_global, 1, MPI_FLOAT, MPI_SUM);
> #endif
> */
382c298
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
404c320
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
427c343
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
452c368
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
476c392
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
498c414
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
540,566d455
< 	void Jacobi_PreConditioner_Mask(
< 						BlockManager& blockManager,
< 						LocalScalar3D<real>* plsx,
< 						LocalScalar3D<real>* plsAp,
< 						LocalScalar3D<real>* plsAw,
< 						LocalScalar3D<real>* plsAe,
< 						LocalScalar3D<real>* plsAs,
< 						LocalScalar3D<real>* plsAn,
< 						LocalScalar3D<real>* plsAb,
< 						LocalScalar3D<real>* plsAt,
< 						LocalScalar3D<real>* plsb,
< 						LocalScalar3D<real>* plsx0,
< 						LocalScalar3D<int>* plsMaskId,
< 						real omega,
< 						int countPreConditioner ) {
< 		for(int count=0; count<countPreConditioner; count++) {
< 			Jacobi_Smoother_Mask(
< 							blockManager,
< 							plsx,
< 							plsAp, plsAw, plsAe, plsAs, plsAn, plsAb, plsAt,
< 							plsb,
< 							plsx0,
< 							plsMaskId,
< 							omega);
< 		}
< 	}
< 
935a825,879
> 	void Jacobi_Mask(
> 						BlockManager& blockManager,
> 						LocalScalar3D<real>* plsx,
> 						LocalScalar3D<real>* plsAp,
> 						LocalScalar3D<real>* plsAw,
> 						LocalScalar3D<real>* plsAe,
> 						LocalScalar3D<real>* plsAs,
> 						LocalScalar3D<real>* plsAn,
> 						LocalScalar3D<real>* plsAb,
> 						LocalScalar3D<real>* plsAt,
> 						LocalScalar3D<real>* plsb,
> 						LocalScalar3D<real>* plsx0,
> 						LocalScalar3D<int>* plsMaskId,
> 						real omega,
> 						int countMax,
> 						real epsilon,
> 						int& count,
> 						real& residual) {
> 		real bb = 0.0;
> 		DOT(blockManager, bb, plsb, plsb);
> 
> 		for(count=1; count<=countMax; ++count) {
> 			Jacobi_Smoother_Mask(
> 							blockManager,
> 							plsx, 
> 							plsAp, plsAw, plsAe, plsAs, plsAn, plsAb, plsAt,
> 							plsb,
> 							plsx0,
> 							plsMaskId,
> 							omega);
> 
> 			real rr = 0.0;
> 			CalcR2(
> 							blockManager,
> 							rr,
> 							plsAp, plsAw, plsAe, plsAs, plsAn, plsAb, plsAt,
> 							plsx,
> 							plsb);
> 
> 			bool bResult = IsConverged(
> 							blockManager,
> 							residual,
> 							rr,
> 							bb,
> 							epsilon,
> 							count,
> 							countMax);
> 			if( bResult == true ) {
> 				break;
> 			}
> 
> 		}
> 		plsx->ImposeBoundaryCondition(blockManager);
> 	}
> 
962a907
> 
964c909
< 		DOT(blockManager, bb, plsb, plsb);
---
> 		DOT_Mask(blockManager, bb, plsb, plsb, plsMaskId);
989c934
< 			DOT(blockManager, rr1, plsr, plsr0);
---
> 			DOT_Mask(blockManager, rr1, plsr, plsr0, plsMaskId);
1017a963
> 
1028c974
< 			CalcAx(
---
> 			CalcAx_Mask(
1032c978,979
< 							plsp_);
---
> 							plsp_,
> 							plsMaskId);
1035c982
< 			DOT(
---
> 			DOT_Mask(
1039c986,987
< 							plsr0);
---
> 							plsr0,
> 							plsMaskId);
1048a997
> 
1051a1001
> 
1062c1012
< 			CalcAx(
---
> 			CalcAx_Mask(
1066c1016,1017
< 							plss_);
---
> 							plss_,
> 							plsMaskId);
1069c1020
< 			DOT(
---
> 			DOT_Mask(
1073c1024,1025
< 							plss);
---
> 							plss,
> 							plsMaskId);
1076c1028
< 			DOT(
---
> 			DOT_Mask(
1080c1032,1033
< 							plst_);
---
> 							plst_,
> 							plsMaskId);
1099c1052
< 			DOT(
---
> 			DOT_Mask(
1103c1056,1057
< 							plsr);
---
> 							plsr,
> 							plsMaskId);
1118a1073,1213
> 
> 		plsx->ImposeBoundaryCondition(blockManager);
> 
> 	}
> 
> 	void DOT_Mask(
> 						BlockManager& blockManager,
> 						real& xy,
> 						LocalScalar3D<real>* plsx,
> 						LocalScalar3D<real>* plsy,
> 						LocalScalar3D<int>* plsMaskId) {
> PM_Start(tm_DOT, 0, 0, true);
> 
> 		int vc = plsx->GetVC();
> 		double xy_local = 0.0;
> 
> 		int NB = blockManager.getNumBlock();
> 		BlockBase* block0 = blockManager.getBlock(0);
> 		::Vec3i size = block0->getSize();
> 		int NX = size.x;
> 		int NY = size.y;
> 		int NZ = size.z;
> 		int sz[3] = {size.x, size.y, size.z};
> 
> PM_Start(tm_DOT_Calc, 0, 0, true);
> #ifdef _BLOCK_IS_LARGE_
> #else
> #pragma omp parallel for reduction(+: xy_local)
> #endif
> 		for (int n=0; n<blockManager.getNumBlock(); ++n) {
> 			BlockBase* block = blockManager.getBlock(n);
> 			real* x = plsx->GetBlockData(block);
> 			real* y = plsy->GetBlockData(block);
> 			int* mask = plsMaskId->GetBlockData(block);
> 
> 			real xy_block = 0.0;
> 			dot_mask_(&xy_block, x, y, mask, sz, &vc);
> 
> 			xy_local += xy_block;
> 		}
> PM_Stop(tm_DOT_Calc, 0, 0, 2.0*NX*NY*NZ, NB);
> 
> 		const MPI::Intracomm& comm = blockManager.getCommunicator();
> 		double xy_global = 0.0;
> 
> PM_Start(tm_DOT_Comm, 0, 0, true);
> 		allreduce_(&xy_global, &xy_local);
> PM_Stop(tm_DOT_Comm);
> 
> 		xy = xy_global;
> 
> PM_Stop(tm_DOT);
> 	}
> 
> 	void Jacobi_PreConditioner_Mask(
> 						BlockManager& blockManager,
> 						LocalScalar3D<real>* plsx,
> 						LocalScalar3D<real>* plsAp,
> 						LocalScalar3D<real>* plsAw,
> 						LocalScalar3D<real>* plsAe,
> 						LocalScalar3D<real>* plsAs,
> 						LocalScalar3D<real>* plsAn,
> 						LocalScalar3D<real>* plsAb,
> 						LocalScalar3D<real>* plsAt,
> 						LocalScalar3D<real>* plsb,
> 						LocalScalar3D<real>* plsx0,
> 						LocalScalar3D<int>* plsMaskId,
> 						real omega,
> 						int countPreConditioner ) {
> 		for(int count=0; count<countPreConditioner; count++) {
> 			Jacobi_Smoother_Mask(
> 							blockManager,
> 							plsx,
> 							plsAp, plsAw, plsAe, plsAs, plsAn, plsAb, plsAt,
> 							plsb,
> 							plsx0,
> 							plsMaskId,
> 							omega);
> 		}
> 	}
> 
> 	void Jacobi_Smoother_Mask(
> 						BlockManager& blockManager,
> 						LocalScalar3D<real>* plsx,
> 						LocalScalar3D<real>* plsAp,
> 						LocalScalar3D<real>* plsAw,
> 						LocalScalar3D<real>* plsAe,
> 						LocalScalar3D<real>* plsAs,
> 						LocalScalar3D<real>* plsAn,
> 						LocalScalar3D<real>* plsAb,
> 						LocalScalar3D<real>* plsAt,
> 						LocalScalar3D<real>* plsb,
> 						LocalScalar3D<real>* plsx0,
> 						LocalScalar3D<int>* plsMaskId,
> 						real omega) {
> 		int vc = plsx->GetVC();
> PM_Start(tm_JacobiSmoother, 0, 0, true);
> 
> 		int NB = blockManager.getNumBlock();
> 		BlockBase* block0 = blockManager.getBlock(0);
> 		::Vec3i size = block0->getSize();
> 		int NX = size.x;
> 		int NY = size.y;
> 		int NZ = size.z;
> 		int sz[3] = {size.x, size.y, size.z};
> 
> PM_Start(tm_JacobiSmoother_Calc, 0, 0, true);
> #ifdef _BLOCK_IS_LARGE_
> #else
> #pragma omp parallel for
> #endif
> 		for (int n=0; n<blockManager.getNumBlock(); ++n) {
> 			BlockBase* block = blockManager.getBlock(n);
> 			real* x  = plsx ->GetBlockData(block);
> 			real* Ap = plsAp->GetBlockData(block);
> 			real* Aw = plsAw->GetBlockData(block);
> 			real* Ae = plsAe->GetBlockData(block);
> 			real* As = plsAs->GetBlockData(block);
> 			real* An = plsAn->GetBlockData(block);
> 			real* Ab = plsAb->GetBlockData(block);
> 			real* At = plsAt->GetBlockData(block);
> 			real* b  = plsb ->GetBlockData(block);
> 			real* x0 = plsx0->GetBlockData(block);
> 			int* mask = plsMaskId->GetBlockData(block);
> 			real pomega = omega;
> 
> 			jacobi_smoother_mask_(
> 							x0, x,
> 							Ap, Aw, Ae, As, An, Ab, At,
> 							b,
> 							mask,
> 							&pomega,
> 							sz, &vc);
> 		}
> PM_Stop(tm_JacobiSmoother_Calc, 0, 0, 16.0*NX*NY*NZ, NB);
> 
> PM_Start(tm_JacobiSmoother_Swap, 0, 0, true);
> 		LSSwap(*plsx, *plsx0);
> PM_Stop(tm_JacobiSmoother_Swap);
> 
> PM_Start(tm_JacobiSmoother_Comm, 0, 0, true);
1119a1215,1217
> PM_Stop(tm_JacobiSmoother_Comm);
> 
> PM_Stop(tm_JacobiSmoother);
1121a1220,1347
> 	void Jacobi_Smoother_Mask_2(
> 						BlockManager& blockManager,
> 						LocalScalar3D<real>* plsx,
> 						LocalScalar3D<real>* plsAp,
> 						LocalScalar3D<real>* plsAw,
> 						LocalScalar3D<real>* plsAe,
> 						LocalScalar3D<real>* plsAs,
> 						LocalScalar3D<real>* plsAn,
> 						LocalScalar3D<real>* plsAb,
> 						LocalScalar3D<real>* plsAt,
> 						LocalScalar3D<real>* plsb,
> 						LocalScalar3D<real>* plsx0,
> 						LocalScalar3D<int>* plsMaskId,
> 						real omega) {
> 		int vc = plsx->GetVC();
> 
> #ifdef _BLOCK_IS_LARGE_
> #else
> #pragma omp parallel for
> #endif
> 		for (int n=0; n<blockManager.getNumBlock(); ++n) {
> 			BlockBase* block = blockManager.getBlock(n);
> 			::Vec3i blockSize = block->getSize();
> 			::Vec3r cellSize  = block->getCellSize();
> 			int sz[3] = {blockSize.x, blockSize.y, blockSize.z};
> 
> 			real* x  = plsx ->GetBlockData(block);
> 			real* Ap = plsAp->GetBlockData(block);
> 			real* Aw = plsAw->GetBlockData(block);
> 			real* Ae = plsAe->GetBlockData(block);
> 			real* As = plsAs->GetBlockData(block);
> 			real* An = plsAn->GetBlockData(block);
> 			real* Ab = plsAb->GetBlockData(block);
> 			real* At = plsAt->GetBlockData(block);
> 			real* b  = plsb ->GetBlockData(block);
> 			real* x0 = plsx0->GetBlockData(block);
> 			int* mask = plsMaskId->GetBlockData(block);
> 			real pomega = omega;
> 
> 			jacobi_smoother_mask_(
> 							x0, x,
> 							Ap, Aw, Ae, As, An, Ab, At,
> 							b,
> 							mask,
> 							&pomega,
> 							sz, &vc);
> 		}
> 
> 		plsx0->UpdateVirtualCells(blockManager);
> 
> #ifdef _BLOCK_IS_LARGE_
> #else
> #pragma omp parallel for
> #endif
> 		for (int n=0; n<blockManager.getNumBlock(); ++n) {
> 			BlockBase* block = blockManager.getBlock(n);
> 			::Vec3i blockSize = block->getSize();
> 			::Vec3r cellSize  = block->getCellSize();
> 			int sz[3] = {blockSize.x, blockSize.y, blockSize.z};
> 
> 			real* x  = plsx ->GetBlockData(block);
> 			real* Ap = plsAp->GetBlockData(block);
> 			real* Aw = plsAw->GetBlockData(block);
> 			real* Ae = plsAe->GetBlockData(block);
> 			real* As = plsAs->GetBlockData(block);
> 			real* An = plsAn->GetBlockData(block);
> 			real* Ab = plsAb->GetBlockData(block);
> 			real* At = plsAt->GetBlockData(block);
> 			real* b  = plsb ->GetBlockData(block);
> 			real* x0 = plsx0->GetBlockData(block);
> 			int* mask = plsMaskId->GetBlockData(block);
> 			real pomega = omega;
> 
> 			jacobi_smoother_mask_(
> 							x, x0,
> 							Ap, Aw, Ae, As, An, Ab, At,
> 							b,
> 							mask,
> 							&pomega,
> 							sz, &vc);
> 		}
> 
> 		plsx->ImposeBoundaryCondition(blockManager);
> 
> 	}
> 
> 	void CalcAx_Mask(
> 						BlockManager& blockManager,
> 						LocalScalar3D<real>* plsAx,
> 						LocalScalar3D<real>* plsAp,
> 						LocalScalar3D<real>* plsAw,
> 						LocalScalar3D<real>* plsAe,
> 						LocalScalar3D<real>* plsAs,
> 						LocalScalar3D<real>* plsAn,
> 						LocalScalar3D<real>* plsAb,
> 						LocalScalar3D<real>* plsAt,
> 						LocalScalar3D<real>* plsx,
> 						LocalScalar3D<int>* plsMaskId) {
> 		int vc = plsx->GetVC();
> #ifdef _BLOCK_IS_LARGE_
> #else
> #pragma omp parallel for
> #endif
> 		for (int n=0; n<blockManager.getNumBlock(); ++n) {
> 			BlockBase* block = blockManager.getBlock(n);
> 			::Vec3i blockSize = block->getSize();
> 			::Vec3r cellSize  = block->getCellSize();
> 			int sz[3] = {blockSize.x, blockSize.y, blockSize.z};
> 
> 			real* Ax = plsAx->GetBlockData(block);
> 			real* Ap = plsAp->GetBlockData(block);
> 			real* Aw = plsAw->GetBlockData(block);
> 			real* Ae = plsAe->GetBlockData(block);
> 			real* As = plsAs->GetBlockData(block);
> 			real* An = plsAn->GetBlockData(block);
> 			real* Ab = plsAb->GetBlockData(block);
> 			real* At = plsAt->GetBlockData(block);
> 			real* x  = plsx ->GetBlockData(block);
> 			int* mask = plsMaskId->GetBlockData(block);
> 
> 			calc_ax_mask_(
> 							Ax,
> 							Ap, Aw, Ae, As, An, Ab, At,
> 							x,
> 							mask,
> 							sz, &vc);
> 		}
> 	}
BCMTools_20130417/examples/SolverTest のみに存在: LeafBlockSaver.o
diff -r BCMTools_20130417/examples/SolverTest/LocalScalar3D.cpp BCMTools_20130709/examples/SolverTest/LocalScalar3D.cpp
3a4
> #include "comm.h"
6a8,18
> 	BlockBase* block0 = blockManager.getBlock(0);
> 	::Vec3i size = block0->getSize();
> 	real* pData0 = GetBlockData(block0);
> 
> 	int m0 = vc + (size.x+2*vc)*(vc + (size.y+2*vc)*vc);
> 	sum_l = 0.0;
> 	max_l = pData0[m0];
> 	min_l = pData0[m0];
> 	absmax_l = abs(pData0[m0]);
> 	absmin_l = abs(pData0[m0]);
> 
19,26c31,35
< 		if( id==0 ) {
< 			int m0 = vc + (size.x+2*vc)*(vc + (size.y+2*vc)*vc);
< 			sum = 0.0;
< 			max = pData[m0];
< 			min = pData[m0];
< 			absmax = abs(pData[m0]);
< 			absmin = abs(pData[m0]);
< 		}
---
> 		real sum_b = 0.0;
> 		real max_b = 0.0;
> 		real min_b = 0.0;
> 		real absmax_b = 0.0;
> 		real absmin_b = 0.0;
28,32c37,41
< 					&sum,
< 					&max,
< 					&min,
< 					&absmax,
< 					&absmin,
---
> 					&sum_b,
> 					&max_b,
> 					&min_b,
> 					&absmax_b,
> 					&absmin_b,
35,70d43
< 	}
< 
< 	real sum_tmp = sum;
< #ifdef _REAL_IS_DOUBLE_		
< 	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
< #else
< 	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_FLOAT, MPI_SUM, MPI_COMM_WORLD);
< #endif
< 
< 	real max_tmp = max;
< #ifdef _REAL_IS_DOUBLE_		
< 	MPI_Allreduce(&max_tmp, &max, 1, MPI_DOUBLE_PRECISION, MPI_MAX, MPI_COMM_WORLD);
< #else
< 	MPI_Allreduce(&max_tmp, &max, 1, MPI_FLOAT, MPI_MAX, MPI_COMM_WORLD);
< #endif
< 
< 	real min_tmp = min;
< #ifdef _REAL_IS_DOUBLE_		
< 	MPI_Allreduce(&min_tmp, &min, 1, MPI_DOUBLE_PRECISION, MPI_MIN, MPI_COMM_WORLD);
< #else
< 	MPI_Allreduce(&min_tmp, &min, 1, MPI_FLOAT, MPI_MIN, MPI_COMM_WORLD);
< #endif
< 
< 	real absmax_tmp = absmax;
< #ifdef _REAL_IS_DOUBLE_		
< 	MPI_Allreduce(&absmax_tmp, &absmax, 1, MPI_DOUBLE_PRECISION, MPI_MAX, MPI_COMM_WORLD);
< #else
< 	MPI_Allreduce(&absmax_tmp, &absmax, 1, MPI_FLOAT, MPI_MAX, MPI_COMM_WORLD);
< #endif
< 
< 	real absmin_tmp = absmin;
< #ifdef _REAL_IS_DOUBLE_		
< 	MPI_Allreduce(&absmin_tmp, &absmin, 1, MPI_DOUBLE_PRECISION, MPI_MIN, MPI_COMM_WORLD);
< #else
< 	MPI_Allreduce(&absmin_tmp, &absmin, 1, MPI_FLOAT, MPI_MIN, MPI_COMM_WORLD);
< #endif
72,80c45,58
< /*
< 	real n_grids = (real)(m_iNX*m_iNY*m_iNZ);
< 	real n_grids_tmp = n_grids;
< #ifdef _REAL_IS_DOUBLE_
< 	MPI_Allreduce(&n_grids_tmp, &n_grids, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
< #else
< 	MPI_Allreduce(&n_grids_tmp, &n_grids, 1, MPI_FLOAT, MPI_SUM, MPI_COMM_WORLD);
< #endif
< */
---
> 		sum_l += sum_b;
> 		if( max_b > max_l ) {
> 			max_l = max_b;
> 		}
> 		if( min_b < min_l ) {
> 			min_l = min_b;
> 		}
> 		if( absmax_b > absmax_l ) {
> 			absmax_l = absmax_b;
> 		}
> 		if( absmin_b < absmin_l ) {
> 			absmin_l = absmin_b;
> 		}
> 	}
82,88c60,64
< /*
< 	m_rAve = sum/n_grids;
< 	m_rMax = max;
< 	m_rMin = min;
< 	m_rAbsMax = absmax;
< 	m_rAbsMin = absmin;
< */
---
> 	allreduce_(&sum_g, &sum_l);
> 	allreduce_max_(&max_g, &max_l);
> 	allreduce_min_(&min_g, &min_l);
> 	allreduce_max_(&absmax_g, &absmax_l);
> 	allreduce_min_(&absmin_g, &absmin_l);
96c72,76
< #ifdef _LARGE_BLOCK_
---
> 	ostringstream ossFileNameTime;
> 	ossFileNameTime << "./BIN/";
> 	mkdir(ossFileNameTime.str().c_str(), 0755);
> 
> #ifdef _BLOCK_IS_LARGE_
152c132
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
233a214,217
> 	ostringstream ossFileNameTime;
> 	ossFileNameTime << "./BIN/";
> 	mkdir(ossFileNameTime.str().c_str(), 0755);
> 
267c251
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
363c347,351
< #ifdef _LARGE_BLOCK_
---
> 	ostringstream ossFileNameTime;
> 	ossFileNameTime << "./BIN/";
> 	mkdir(ossFileNameTime.str().c_str(), 0755);
> 
> #ifdef _BLOCK_IS_LARGE_
414c402
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
diff -r BCMTools_20130417/examples/SolverTest/LocalScalar3D.h BCMTools_20130709/examples/SolverTest/LocalScalar3D.h
7a8
> #include "Scalar3DUpdater1.h"
10a12
> #include "gv.h"
26c28,32
< 		if( updaterType == 2 ) {
---
> 		if( updaterType == 1 ) {
> 			this->id = blockManager.setDataClass<Scalar3D<T>, Scalar3DUpdater1<T> >(this->vc);
> 		} else if( updaterType == 10 ) {
> 			this->id = blockManager.setDataClass<Scalar3D<T>, Scalar3DUpdater1<T>, T >(this->vc);
> 		} else if( updaterType == 2 ) {
31a38,49
> /*
> 		blockDataTable = new T* [blockManager.getNumBlock()];
> #ifdef _BLOCK_IS_LARGE_
> #else
> #endif
> 		for (int n=0; n<blockManager.getNumBlock(); n++) {
> 			BlockBase* block = blockManager.getBlock(n);
> 			T*    blockData = this->GetBlockData(block);
> 			this->blockDataTable[n] = blockData;
> 		}
> */
> 
44c62
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
78a97,99
> /*
> 	T** blockDataTable;
> */
81,85c102,112
< 	T sum;
< 	T max;
< 	T min;
< 	T absmax;
< 	T absmin;
---
> 	T sum_l;
> 	T max_l;
> 	T min_l;
> 	T absmax_l;
> 	T absmin_l;
> 
> 	T sum_g;
> 	T max_g;
> 	T min_g;
> 	T absmax_g;
> 	T absmin_g;
88d114
< /*
90,93d115
< 		int vc_tmp = x1.vc;
< 		x1.vc = x0.vc;
< 		x0.vc = vc_tmp;
< 
97,104d118
< 
< 		bool separateVCUpdate_tmp = x1.separateVCUpdate;
< 		x1.separateVCUpdate = x0.separateVCUpdate;
< 		x0.separateVCUpdate = separateVCUpdate_tmp;
< 
< 		BlockScalar3D<T>* blockScalar3D_tmp = x1.blockScalar3D;
< 		x1.blockScalar3D = x0.blockScalar3D;
< 		x0.blockScalar3D = blockScalar3D_tmp;
106d119
< */
118c131
< 		return sum;
---
> 		return sum_g;
122c135
< 		return max;
---
> 		return max_g;
126c139
< 		return min;
---
> 		return min_g;
130c143
< 		return absmax;
---
> 		return absmax_g;
134c147,151
< 		return absmin;
---
> 		return absmin_g;
> 	}
> 
> 	T GetSumL() {
> 		return sum_l;
136a154,170
> 	T GetMaxL() {
> 		return max_l;
> 	}
> 
> 	T GetMinL() {
> 		return min_l;
> 	}
> 
> 	T GetAbsMaxL() {
> 		return absmax_l;
> 	}
> 
> 	T GetAbsMinL() {
> 		return absmin_l;
> 	}
> 
> 
142c176,182
< 	void ImposeBoundaryCondition(
---
> /*
> 	T* GetBlockData(int n) {
> 		return this->blockDataTable[n];
> 	}
> */
> 
> 	void UpdateVirtualCells(
148d187
< 				ImposeBlockBoundaryCondition(blockManager);
157d195
< 				ImposeBlockBoundaryCondition(blockManager);
159a198,200
> 				blockManager.updateVC_X_F2C(this->id);
> 				blockManager.updateVC_Y_F2C(this->id);
> 				blockManager.updateVC_Z_F2C(this->id);
162a204,228
> 				blockManager.updateVC_X_C2F(this->id);
> 				blockManager.updateVC_Y_C2F(this->id);
> 				blockManager.updateVC_Z_C2F(this->id);
> 				break;
> 		}
> 	}
> 
> 	void ImposeBoundaryCondition(
> 										BlockManager& blockManager) {
> 		switch(this->updateMethod) {
> 			case VCUpdateMethod::AtOnce:
> 				blockManager.beginUpdateVC(this->id);
> 				blockManager.endUpdateVC(this->id);
> 				ImposeBlockBoundaryCondition(blockManager);
> 				break;
> 			case VCUpdateMethod::SeparateXYZ:
> 				blockManager.beginUpdateVC_X(this->id);
> 				blockManager.endUpdateVC_X(this->id);
> 				blockManager.beginUpdateVC_Y(this->id);
> 				blockManager.endUpdateVC_Y(this->id);
> 				blockManager.beginUpdateVC_Z(this->id);
> 				blockManager.endUpdateVC_Z(this->id);
> 				ImposeBlockBoundaryCondition(blockManager);
> 				break;
> 			case VCUpdateMethod::SeparateXYZ_SeparateLevelDiff:
165a232,234
> 				blockManager.updateVC_X_Flat(this->id);
> 				blockManager.updateVC_Y_Flat(this->id);
> 				blockManager.updateVC_Z_Flat(this->id);
184c253
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
205c274
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
215c284
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
265,266c334,335
< 	void Fill(BlockManager& blockManager, T value) {
< #ifdef _LARGE_BLOCK_
---
> 	void Fill(BlockManager& blockManager, T value, T deviation=0.0) {
> #ifdef _BLOCK_IS_LARGE_
280a350
> 						blockData[mp] = RandomNormal(value, deviation);
BCMTools_20130417/examples/SolverTest のみに存在: LocalScalar3D.o
diff -r BCMTools_20130417/examples/SolverTest/Makefile BCMTools_20130709/examples/SolverTest/Makefile
17c17
< include ../../make_setting.gnu
---
> include ../make_setting.gnu
21c21
< include ../../make_setting.fx
---
> include ../make_setting.fx
25c25
< include ../../make_setting.ibm
---
> include ../make_setting.ibm
29c29
< include ../../make_setting.intel
---
> include ../make_setting.intel
34c34
< UTIL    = ../util
---
> #UTIL    = ../util
36,37c36,37
< UDEF_INC_PATH=-I$(CUTLIB_DIR)/include \
<               -I$(POLYLIB_DIR)/include \
---
> UDEF_INC_PATH=-I$(POLYLIB_DIR)/include \
>               -I$(CUTLIB_DIR)/include \
40,41d39
< 							-I$(BCM_DIR)/include \
< 							-I$(BCM_FILEIO_DIR)/include \
43,45c41,45
< 							-I$(UTIL)/include \
<               -I$(MPI_DIR)/include
<               
---
>               -I$(MPI_DIR)/include \
>  							-I$(BCM_DIR)/include \
> 							-I$(BCM_FILEIO)/include \
> 							-I$(BCM_UTILS)/include 
>              
60,61c60,69
< vpath %.cpp $(UTIL)/src
< vpath %.cpp $(BCM_FILEIO_DIR)/src
---
> GIT_VERSION = $(shell sh -c 'git describe --always --dirty')
> #GIT_DATE    = $(shell sh -c 'date --iso=seconds')
> BUILD_DATE    = $(shell sh -c 'date +%s')
> 
> VERSION_FLAGS = -D__GIT_VERSION=\"$(GIT_VERSION)\" -D__BUILD_DATE=\"$(BUILD_DATE)\"
> CXXFLAGS += $(VERSION_FLAGS)
> CFLAGS   += $(VERSION_FLAGS)
> 
> vpath %.cpp $(BCM_FILEIO)/src
> vpath %.cpp $(BCM_UTILS)/src
67c75
< UTIL_OBJS = ConfigFile.o ConfigBase.o BCMOctree.o BCMPolylib.o
---
> BCM_UTILS_OBJS = ConfigFile.o ConfigBase.o BCMOctree.o BCMPolylib.o
70c78
< PROGRAM: $(OBJS) $(UTIL_OBJS) $(BCM_FILEIO_OBJS)
---
> PROGRAM: $(OBJS) $(BCM_UTILS_OBJS) $(BCM_FILEIO_OBJS)
74c82
< 	-o $(PROGRAM) $(OBJS) $(UTIL_OBJS) $(BCM_FILEIO_OBJS) \
---
> 	-o $(PROGRAM) $(OBJS) $(BCM_UTILS_OBJS) $(BCM_FILEIO_OBJS) \
80c88
< 	$(CXX) $(CXXFLAGS) $(UDEF_INC_PATH) $(UDEF_OPT) $(XG) -o $@ -c $<
---
> 	$(CXX) $(CXXFLAGS) $(UDEF_INC_PATH) $(UDEF_OPT) -o $@ -c $<
84c92
< 	$(F90) $(F90FLAGS) $(UDEF_OPT) $(XG) -o $@ -c $<
---
> 	$(F90) $(F90FLAGS) $(UDEF_INC_PATH) $(UDEF_OPT) -o $@ -c $<
90c98
< 	rm -rf BIN STL VTI data-*
---
> 	rm -rf BIN STL VTK PLOT3D BCM_OUT data-*
93c101
< 	$(CXX) $(XG) -MM $(CSRC) $(CXXFLAGS) $(UDEF_INC_PATH) $(UDEF_OPT) > depend.inc
---
> 	$(CXX) -MM $(CSRC) $(CXXFLAGS) $(UDEF_INC_PATH) $(UDEF_OPT) > depend.inc
BCMTools_20130709/examples/SolverTest のみに存在: PM.cpp
BCMTools_20130709/examples/SolverTest のみに存在: PM.h
BCMTools_20130709/examples/SolverTest のみに存在: Plot3DWriter.h
BCMTools_20130709/examples/SolverTest のみに存在: Scalar3DUpdater1.cpp
BCMTools_20130709/examples/SolverTest のみに存在: Scalar3DUpdater1.h
BCMTools_20130417/examples/SolverTest のみに存在: Scalar3DUpdater2.cpp
diff -r BCMTools_20130417/examples/SolverTest/Scalar3DUpdater2.h BCMTools_20130709/examples/SolverTest/Scalar3DUpdater2.h
246c246,247
<     I = std::min(std::max(i/2 - 1 + i%2, 0), n - 2);
---
> //    I = std::min(std::max(i/2 - 1 + i%2, 0), n - 2);
>     I = i/2 - 1 + i%2;
BCMTools_20130417/examples/SolverTest のみに存在: Scalar3DUpdater2.o
diff -r BCMTools_20130417/examples/SolverTest/Solver.cpp BCMTools_20130709/examples/SolverTest/Solver.cpp
9d8
< 
10a10
> #include "comm.h"
19a20
> #include "SphereDivider3.h"
21c22
< #include "BoundaryConditionSetter.h"
---
> //#include "BoundaryConditionSetter.h"
28a30
> #include "GridAccessor/Cell.h"
31a34
> #include "PM.h"
33,35c36
< #ifdef __K_FPCOLL
< #include <fjcoll.h>
< #endif
---
> #include "outputVtk.h"
37,39c38,40
< #ifdef __K_FAPP
< #include <fj_tool/fapp.h>
< #endif
---
> #define GLOBAL_VALUE_DEFINE
> #include "gv.h"
> #undef GLOBAL_VALUE_DEFINE
65,66c66,70
< 	int myrank = comm.Get_rank();
< 	rank = myrank;
---
> 	this->myrank = comm.Get_rank();
> 	if( argc != 2 ) {
> 		PrintLog(0, "usage: %s configfile", argv[0]);
> 		comm.Abort(EX_USAGE);
> 	}
68,73c72,76
< 	if( myrank == 0 ) {
< 		if( argc != 2 ) {
< 			std::cout << "usage: " << argv[0] << " configfile" << std::endl;
< 			comm.Abort(EX_USAGE);
< 		}
<     std::cout << "# of MPI processes = " << comm.Get_size() << std::endl;
---
> 	PrintLog(1, GetSolverName().c_str());
> 	PrintLog(2, "%-20s : %s", "Git hash", __GIT_VERSION);
> 	PrintLog(2, "%-20s : %s", "Build date", __BUILD_DATE);
> 	PrintLog(2, "%-20s : %s", "Configuration file", argv[1]);
> 	PrintLog(2, "%-20s : %d", "MPI processes", comm.Get_size());
75c78
<     std::cout << "# of OpenMP threads = " << omp_get_max_threads() << std::endl;
---
> 	PrintLog(2, "%-20s : %d", "OpenMP threads", omp_get_max_threads());
77,78d79
<     std::cout <<  std::endl << "Configuration file: " << argv[1] << std::endl;
< 	}
82d82
< 
85a86
> 	PrintLog(1, "Loading configuration file");
86a88,89
> 	g_pconf = &conf;
> /*
90c93
< /////////////////////////////////////////////
---
> */
91a95,127
> 	PrintLog(2, "%-20s : %d", "min level", conf.minLevel);
> 	PrintLog(2, "%-20s : %d", "max level", conf.maxLevel);
> 	PrintLog(2, "%-20s : %s", "tree type", conf.treeType.c_str());
> 	PrintLog(2, "%-20s : %s", "ordering",  conf.ordering.c_str());
> 	PrintLog(2, "%-20s : %d", "block size", conf.size);
> 	PrintLog(2, "%-20s : %d", "vc width", conf.vc);
> 
> 	g_pPM = new pm_lib::PerfMonitor;
> 	g_pPM->initialize(tm_END);
> 	g_pPM->setRankInfo(this->myrank);
> 	g_pPM->setProperties(tm_Init_LoadSTL,      "LoadSTL",      pm_lib::PerfMonitor::COMM, true);
> 	g_pPM->setProperties(tm_Init_DivideDomain, "DivideDomain", pm_lib::PerfMonitor::CALC, true);
> 	g_pPM->setProperties(tm_Init_OrderBlock,   "OrderBlock",   pm_lib::PerfMonitor::CALC, true);
> 	g_pPM->setProperties(tm_Update,   "Update",   pm_lib::PerfMonitor::CALC, false);
> 	g_pPM->setProperties(tm_UpdateT,  "UpdateT",  pm_lib::PerfMonitor::CALC, false);
> 	g_pPM->setProperties(tm_UpdateUX, "UpdateUX", pm_lib::PerfMonitor::CALC, false);
> 	g_pPM->setProperties(tm_UpdateUY, "UpdateUY", pm_lib::PerfMonitor::CALC, false);
> 	g_pPM->setProperties(tm_UpdateUZ, "UpdateUZ", pm_lib::PerfMonitor::CALC, false);
> 	g_pPM->setProperties(tm_UpdateP,  "UpdateP",  pm_lib::PerfMonitor::CALC, false);
> 	g_pPM->setProperties(tm_UpdateU,  "UpdateU",  pm_lib::PerfMonitor::CALC, false);
> 	g_pPM->setProperties(tm_DOT,      "DOT",      pm_lib::PerfMonitor::CALC, false);
> 	g_pPM->setProperties(tm_DOT_Calc, "DOT_Calc", pm_lib::PerfMonitor::CALC, true);
> 	g_pPM->setProperties(tm_DOT_Comm, "DOT_Comm", pm_lib::PerfMonitor::COMM, true);
> 	g_pPM->setProperties(tm_JacobiSmoother,      "JacobiSmoother",      pm_lib::PerfMonitor::CALC, false);
> 	g_pPM->setProperties(tm_JacobiSmoother_Calc, "JacobiSmoother_Calc", pm_lib::PerfMonitor::CALC, true);
> 	g_pPM->setProperties(tm_JacobiSmoother_Swap, "JacobiSmoother_Swap", pm_lib::PerfMonitor::CALC, true);
> 	g_pPM->setProperties(tm_JacobiSmoother_Comm, "JacobiSmoother_Comm", pm_lib::PerfMonitor::COMM, true);
> 	int nThreads = 1;
> #ifdef _OPENMP
> 	nThreads = omp_get_max_threads();
> #endif
> 	g_pPM->setParallelMode("Hybrid", nThreads, comm.Get_size());
> /////////////////////////////////////////////
96a133,135
> 	PrintLog(1, "Loading STL file(s)");
> 
> 	PM_Start(tm_Init_LoadSTL, 0, 0, false);
98,102c137,139
< 	if(myrank == 0) {
< 		if (conf.polygonGroupList.size() > 0) {
< 			if (pl->load(conf.polylibConfig) != PLSTAT_OK) {
< 				comm.Abort(EX_OPEN_FILE);
< 			}
---
> 	if (conf.polygonGroupList.size() > 0) {
> 		if (pl->load(conf.polylibConfig) != PLSTAT_OK) {
> 			comm.Abort(EX_OPEN_FILE);
104a142
> 	PM_Stop(tm_Init_LoadSTL);
106,108c144,147
< //  BCMOctree* tree = 0;
< 	tree = 0;
< 	if( myrank == 0 ) {
---
> 	if(myrank == 0) {
> 		PrintLog(1, "Building BCMOctree");
> 
> 		PM_Start(tm_Init_DivideDomain, 0, 0, false);
109a149,157
> 		if( conf.periodicX ) {
> 			rootGrid->setPeriodicX();
> 		}
> 		if( conf.periodicY ) {
> 			rootGrid->setPeriodicY();
> 		}
> 		if( conf.periodicZ ) {
> 			rootGrid->setPeriodicZ();
> 		}
141a190,200
> 		} else if (conf.treeType == "sphere3") {
> 			divider = new SphereDivider3(
> 												conf.origin,
> 												conf.rootLength,
> 												rootGrid,
> 												conf.minLevel,
> 												pl,
> 												conf.polygonGroupList,
> 												conf.boundingBoxList,
> 												conf.sphericalBoxList,
> 												(double)conf.vc/conf.size);
167a227
> 		PM_Stop(tm_Init_DivideDomain);
168a229
> 		PM_Start(tm_Init_OrderBlock, 0, 0, false);
180a242
> 		PM_Stop(tm_Init_OrderBlock);
189,190d250
< 
< //  Partition* partition = new Partition(comm.Get_size(), numLeafNode);
192,196c252,258
< 
<   if (myrank == 0) {
<     std::cout << std::endl << "Partitioning" << std::endl;
<     partition->print();
<   }
---
> 	for(int n=0; n<comm.Get_size(); n++) {
> 		if( n==0 ) {
> 			PrintLog(2, "%-20s : #%05d [%04d:%04d] (%04d)",  "Partitions", n, partition->getStart(n), partition->getEnd(n)-1, partition->getEnd(n) - partition->getStart(n));
> 		} else {
> 			PrintLog(2, "%-20s : #%05d [%04d:%04d] (%04d)",  "", n, partition->getStart(n), partition->getEnd(n)-1, partition->getEnd(n) - partition->getStart(n));
> 		}
> 	}
213a276,295
> 			switch(i) {
> 				case 0:
> 				case 1:
> 					if( conf.periodicX == true ) {
> 						continue;
> 					}
> 					break;
> 				case 2:
> 				case 3:
> 					if( conf.periodicY == true ) {
> 						continue;
> 					}
> 					break;
> 				case 4:
> 				case 5:
> 					if( conf.periodicZ == true ) {
> 						continue;
> 					}
> 					break;
> 			}
222a305
>   blockManager.printBlockLayoutInfo("data-block.txt");
246a330,332
> 
> 	cutlib::RepairPolygonData(pl);
> 
249c335
< 	pl->save_parallel(&file, "stl_b");
---
> 	pl->save_parallel(&file, "stl", "test");
252d337
< 
260,263c345,346
< 	int maxLevel = 0;
< #ifdef _LARGE_BLOCK_
< #else
< #endif
---
> 	maxLevel = 0;
> 	minLevel = INT_MAX;
269a353,355
> 		if( level <= minLevel ) {
> 			minLevel = level;
> 		}
272d357
< 
274d358
< 
339d422
< 	plsx0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeNULL, boundaryValueNULL);
348d430
< 	plsx0->Fill(blockManager, 0.0);
381,383c463
< 	if( myrank == 0 ) {
< 		std::cerr << "Computing cuts" << std::endl;
< 	}
---
> 	PrintLog(1, "Computing cuts");
413c493,494
< #ifdef _LARGE_BLOCK_
---
> 
> #ifdef _BLOCK_IS_LARGE_
418,419c499,500
< 		::Vec3i size = block->getSize();
< 		::Vec3r origin = block->getOrigin();
---
> 		::Vec3i size      = block->getSize();
> 		::Vec3r origin    = block->getOrigin();
421c502
< 		::Vec3r cellSize = block->getCellSize();
---
> 		::Vec3r cellSize  = block->getCellSize();
426c507
< 		float bpos[3] = {origin.x, origin.y, origin.z};
---
> 		double bpos[3] = {origin.x, origin.y, origin.z};
429c510
< 		float dx[3] = {cellSize.x, cellSize.x, cellSize.x};
---
> 		double dx[3] = {cellSize.x, cellSize.x, cellSize.x};
431c512
< 		float org[3];
---
> 		double org[3];
437,438c518,520
< 		cutlib::CutPos32Array *cutPos = new cutlib::CutPos32Array(ncell);
< 		cutlib::CutBid5Array  *cutBid = new cutlib::CutBid5Array(ncell);
---
> 		cutlib::GridAccessor* grid   = new cutlib::Cell(org, dx);
> 		cutlib::CutPosArray*  cutPos = new cutlib::CutPos32Array(ncell);
> 		cutlib::CutBidArray*  cutBid = new cutlib::CutBid5Array(ncell);
440c522,523
< 		CutInfoCell(org, dx, pl, cutPos, cutBid);
---
> //		CutInfoCell(org, dx, pl, cutPos, cutBid);
> 		CalcCutInfo(grid, pl, cutPos, cutBid);
442,486c525
< 		float*   cut = (float*)cutPos->getDataPointer();
< 		int* bid = (int*)cutBid->getDataPointer();
< 
< 		real* cut_real = new real [6*ncell[0]*ncell[1]*ncell[2]];
< 
< 
< #ifdef _LARGE_BLOCK_
< #pragma omp parallel for
< #else
< #endif
< 		for(int k=vc; k<vc+size.z; k++) {
< 			for(int j=vc; j<vc+size.y; j++) {
< 				for(int i=vc; i<vc+size.x; i++) {
< 					int m = i + (2*vc + size.x)*(j + (2*vc + size.y)*k);
< 					float cut0 = cut[6*m + 0];
< 					float cut1 = cut[6*m + 1];
< 					float cut2 = cut[6*m + 2];
< 					float cut3 = cut[6*m + 3];
< 					float cut4 = cut[6*m + 4];
< 					float cut5 = cut[6*m + 5];
< 
< 					cut_real[6*m + 0] = cut0;
< 					cut_real[6*m + 1] = cut1;
< 					cut_real[6*m + 2] = cut2;
< 					cut_real[6*m + 3] = cut3;
< 					cut_real[6*m + 4] = cut4;
< 					cut_real[6*m + 5] = cut5;
< /*
< 					std::cout.setf(std::ios::scientific);
< 					std::cout << cut0;
< 					std::cout << " ";
< 					std::cout << cut1;
< 					std::cout << " ";
< 					std::cout << cut2;
< 					std::cout << " ";
< 					std::cout << cut3;
< 					std::cout << " ";
< 					std::cout << cut4;
< 					std::cout << " ";
< 					std::cout << cut5;
< 					std::cout << std::endl;
< */
< 				}
< 			}
< 		}
---
> //		outputVtk("test_2_", n + blockManager.getNumBlock()*myrank, grid, cutPos, cutBid);
500,508c539,542
< 
< 		bstl_read_cut_(
< 						pCut0, pCut1, pCut2, pCut3, pCut4, pCut5,
< 						pCutId0, pCutId1, pCutId2, pCutId3, pCutId4, pCutId5,
< 						cut_real,
< 						bid,
< 						sz, g);
< 
< /*
---
> #ifdef _BLOCK_IS_LARGE_
> #pragma omp parallel for
> #else
> #endif
513,544c547,582
< 					float cut0 = cut[6*m + 0];
< 					float cut1 = cut[6*m + 1];
< 					float cut2 = cut[6*m + 2];
< 					float cut3 = cut[6*m + 3];
< 					float cut4 = cut[6*m + 4];
< 					float cut5 = cut[6*m + 5];
< 
< 					std::cout.setf(std::ios::scientific);
< 					std::cout << pCut0[m];
< 					std::cout << " ";
< 					std::cout << cut0;
< 					std::cout << std::endl;
< 					std::cout << pCut1[m];
< 					std::cout << " ";
< 					std::cout << cut1;
< 					std::cout << std::endl;
< 					std::cout << pCut2[m];
< 					std::cout << " ";
< 					std::cout << cut2;
< 					std::cout << std::endl;
< 					std::cout << pCut3[m];
< 					std::cout << " ";
< 					std::cout << cut3;
< 					std::cout << std::endl;
< 					std::cout << pCut4[m];
< 					std::cout << " ";
< 					std::cout << cut4;
< 					std::cout << std::endl;
< 					std::cout << pCut5[m];
< 					std::cout << " ";
< 					std::cout << cut5;
< 					std::cout << std::endl;
---
> 					float cut0 = cutPos->getPos(i, j, k, 0);
> 					float cut1 = cutPos->getPos(i, j, k, 1);
> 					float cut2 = cutPos->getPos(i, j, k, 2);
> 					float cut3 = cutPos->getPos(i, j, k, 3);
> 					float cut4 = cutPos->getPos(i, j, k, 4);
> 					float cut5 = cutPos->getPos(i, j, k, 5);
> 					cutlib::BidType bid0 = cutBid->getBid(i, j, k, 0);
> 					cutlib::BidType bid1 = cutBid->getBid(i, j, k, 1);
> 					cutlib::BidType bid2 = cutBid->getBid(i, j, k, 2);
> 					cutlib::BidType bid3 = cutBid->getBid(i, j, k, 3);
> 					cutlib::BidType bid4 = cutBid->getBid(i, j, k, 4);
> 					cutlib::BidType bid5 = cutBid->getBid(i, j, k, 5);
> 					if( (int)bid0 != 0 ) {
> 						pCut0[m] = cut0;
> 					}
> 					if( (int)bid1 != 0 ) {
> 						pCut1[m] = cut1;
> 					}
> 					if( (int)bid2 != 0 ) {
> 						pCut2[m] = cut2;
> 					}
> 					if( (int)bid3 != 0 ) {
> 						pCut3[m] = cut3;
> 					}
> 					if( (int)bid4 != 0 ) {
> 						pCut4[m] = cut4;
> 					}
> 					if( (int)bid5 != 0 ) {
> 						pCut5[m] = cut5;
> 					}
> 					pCutId0[m] = bid0;
> 					pCutId1[m] = bid1;
> 					pCutId2[m] = bid2;
> 					pCutId3[m] = bid3;
> 					pCutId4[m] = bid4;
> 					pCutId5[m] = bid5;
548c586,588
< */
---
> 		delete grid;
> 		delete cutPos;
> 		delete cutBid;
572,575d611
< 
< 		delete cutPos;
< 		delete cutBid;
< 		delete [] cut_real;
576a613
> 
592c629
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
643,645c680,681
< 		if( rank == 0 ) {
< 			std::cout << "# of zero-cut cells = " << countLocal << std::endl;
< 		}
---
> 
> 		PrintLog(2, "%-20s : %d", "Zero distance", countLocal);
650c686
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
677a714,717
> 			int bClose = 1;
> 			if( conf.holefilling == false ) {
> 				bClose = 0;
> 			}
681a722
> 							&bClose,
682a724
> 
700,702c742,815
< 		if( rank == 0 ) {
< 			std::cout << "# of holes = " << countLocal << std::endl;
< 		}
---
> 
> 		PrintLog(2, "%-20s : %d", "Hole faces(single)", countLocal);
> 	}
> 
> 	{
> 		int nIterationCount = 0;
> 		int countLocal = 0;
> 		int countTotal = 0;
> 		do {
> 			countLocal = 0;
> 
> #ifdef _BLOCK_IS_LARGE_
> #else
> #pragma omp parallel for reduction(+: countLocal)
> #endif
> 			for (int n=0; n<blockManager.getNumBlock(); ++n) {
> 				BlockBase* block = blockManager.getBlock(n);
> 				::Vec3i size = block->getSize();
> 				::Vec3r origin = block->getOrigin();
> 				::Vec3r blockSize = block->getBlockSize();
> 				::Vec3r cellSize = block->getCellSize();
> 
> 				int sz[3] = {size.x, size.y, size.z};
> 				int g[1] = {vc};
> 
> 				real* pCut0 = plsCut0->GetBlockData(block);
> 				real* pCut1 = plsCut1->GetBlockData(block);
> 				real* pCut2 = plsCut2->GetBlockData(block);
> 				real* pCut3 = plsCut3->GetBlockData(block);
> 				real* pCut4 = plsCut4->GetBlockData(block);
> 				real* pCut5 = plsCut5->GetBlockData(block);
> 				int* pCutId0 = plsCutId0->GetBlockData(block);
> 				int* pCutId1 = plsCutId1->GetBlockData(block);
> 				int* pCutId2 = plsCutId2->GetBlockData(block);
> 				int* pCutId3 = plsCutId3->GetBlockData(block);
> 				int* pCutId4 = plsCutId4->GetBlockData(block);
> 				int* pCutId5 = plsCutId5->GetBlockData(block);
> 
> 				int count = 0;
> 				int bClose = 1;
> 				if( conf.holefilling2 == false ) {
> 					bClose = 0;
> 				}
> 
> 				bstl_fill_holes_v2_(
> 								pCut0, pCut1, pCut2, pCut3, pCut4, pCut5,
> 								pCutId0, pCutId1, pCutId2, pCutId3, pCutId4, pCutId5,
> 								&count,
> 								&bClose,
> 								sz, g);
> 
> 				countLocal += count;
> 			}
> 			plsCut0->ImposeBoundaryCondition(blockManager);
> 			plsCut1->ImposeBoundaryCondition(blockManager);
> 			plsCut2->ImposeBoundaryCondition(blockManager);
> 			plsCut3->ImposeBoundaryCondition(blockManager);
> 			plsCut4->ImposeBoundaryCondition(blockManager);
> 			plsCut5->ImposeBoundaryCondition(blockManager);
> 			plsCutId0->ImposeBoundaryCondition(blockManager);
> 			plsCutId1->ImposeBoundaryCondition(blockManager);
> 			plsCutId2->ImposeBoundaryCondition(blockManager);
> 			plsCutId3->ImposeBoundaryCondition(blockManager);
> 			plsCutId4->ImposeBoundaryCondition(blockManager);
> 			plsCutId5->ImposeBoundaryCondition(blockManager);
> 
> 			int countTmp = countLocal;
> 			MPI_Allreduce(&countTmp, &countLocal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
> 
> 			nIterationCount++;
> 			countTotal += countLocal;
> 		}while( countLocal > 0 && conf.holefilling2 == true);
> 
> 		PrintLog(2, "%-20s : %d (#Ite.: %d)", "Hole faces(multi)", countTotal, nIterationCount);
704a818,819
> 	PrintLog(1, "Filling");
> 
708,710c823
< 	if( rank == 0 ) {
< 		std::cout << "seed = (" << xs << ", " << ys << ", " << zs << ")" << std::endl;
< 	}
---
> 	PrintLog(2, "%-20s : %f %f %f", "Seed for FLUID", xs, ys, zs);
712c825
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
726d838
< //		std::cout << origin.y << " " << origin.y + sz[1]*dx << std::endl;
739a852,883
> 	{
> 		int nIterationCount = 0;
> 		long int nCellsChanged = 0;
> 		do {
> 			nCellsChanged = 0;
> #ifdef _BLOCK_IS_LARGE_
> #else
> //#pragma omp parallel for reduction(+: nCellsChanged)
> #endif
> 			for (int n=0; n<blockManager.getNumBlock(); ++n) {
> 				BlockBase* block = blockManager.getBlock(n);
> 				::Vec3i size = block->getSize();
> 				::Vec3r origin = block->getOrigin();
> 				::Vec3r blockSize = block->getBlockSize();
> 				::Vec3r cellSize = block->getCellSize();
> 
> 				int sz[3] = {size.x, size.y, size.z};
> 				int g[1] = {vc};
> 				int nc[3] = {size.x + 2*vc, size.y + 2*vc, size.z + 2*vc};
> 
> 				real* pCut0 = plsCut0->GetBlockData(block);
> 				real* pCut1 = plsCut1->GetBlockData(block);
> 				real* pCut2 = plsCut2->GetBlockData(block);
> 				real* pCut3 = plsCut3->GetBlockData(block);
> 				real* pCut4 = plsCut4->GetBlockData(block);
> 				real* pCut5 = plsCut5->GetBlockData(block);
> 				int* pCutId0 = plsCutId0->GetBlockData(block);
> 				int* pCutId1 = plsCutId1->GetBlockData(block);
> 				int* pCutId2 = plsCutId2->GetBlockData(block);
> 				int* pCutId3 = plsCutId3->GetBlockData(block);
> 				int* pCutId4 = plsCutId4->GetBlockData(block);
> 				int* pCutId5 = plsCutId5->GetBlockData(block);
740a885,925
> 				int* pPhaseId = plsPhaseId->GetBlockData(block);
> #ifdef _BLOCK_IS_LARGE_
> //#pragma omp parallel for reduction(+: nCellsChanged)
> #else
> #endif
> 				for(int k=vc; k<=size.z+vc-1; k++) {
> 					for(int j=vc; j<=size.y+vc-1; j++) {
> 						for(int i=vc; i<=size.x+vc-1; i++) {
> 							int mp = i + nc[0]*( j + nc[1]*k );
> 							int mw = i-1 + nc[0]*( j + nc[1]*k );
> 							int me = i+1 + nc[0]*( j + nc[1]*k );
> 							int ms = i + nc[0]*( j-1 + nc[1]*k );
> 							int mn = i + nc[0]*( j+1 + nc[1]*k );
> 							int mb = i + nc[0]*( j + nc[1]*(k-1) );
> 							int mt = i + nc[0]*( j + nc[1]*(k+1) );
> 
> 							int cidp0 = pCutId0[mp];
> 							int cidp1 = pCutId1[mp];
> 							int cidp2 = pCutId2[mp];
> 							int cidp3 = pCutId3[mp];
> 							int cidp4 = pCutId4[mp];
> 							int cidp5 = pCutId5[mp];
> 
> 							if( pPhaseId[mp] > 0 ) {
> 								continue;
> 							}
> 
> 							if( (pPhaseId[mw] == 1 && cidp0 == 0) ||
> 									(pPhaseId[me] == 1 && cidp1 == 0) ||
> 									(pPhaseId[ms] == 1 && cidp2 == 0) ||
> 									(pPhaseId[mn] == 1 && cidp3 == 0) ||
> 									(pPhaseId[mb] == 1 && cidp4 == 0) ||
> 									(pPhaseId[mt] == 1 && cidp5 == 0) ) {
> 								pPhaseId[mp] = 1;
> 								nCellsChanged++;
> 							}
> 						}
> 					}
> 				}
> 			}
> 			plsPhaseId->ImposeBoundaryCondition(blockManager);
741a927,928
> 			long int nCellsChangedTmp = nCellsChanged;
> 			MPI_Allreduce(&nCellsChangedTmp, &nCellsChanged, 1, MPI_LONG_LONG_INT, MPI_SUM, MPI_COMM_WORLD);
743,746c930,931
< 	int nIterationCount = 0;
< 	long int nCellsChanged = 0;
< 	do {
< 		nCellsChanged = 0;
---
> 			nIterationCount++;
> 		}while(nCellsChanged>0);
748c933,935
< #ifdef _LARGE_BLOCK_
---
> 		long int count = 0;
> 		long int countS = 0;
> #ifdef _BLOCK_IS_LARGE_
750d936
< //#pragma omp parallel for reduction(+: nCellsChanged)
763,775d948
< 			real* pCut0 = plsCut0->GetBlockData(block);
< 			real* pCut1 = plsCut1->GetBlockData(block);
< 			real* pCut2 = plsCut2->GetBlockData(block);
< 			real* pCut3 = plsCut3->GetBlockData(block);
< 			real* pCut4 = plsCut4->GetBlockData(block);
< 			real* pCut5 = plsCut5->GetBlockData(block);
< 			int* pCutId0 = plsCutId0->GetBlockData(block);
< 			int* pCutId1 = plsCutId1->GetBlockData(block);
< 			int* pCutId2 = plsCutId2->GetBlockData(block);
< 			int* pCutId3 = plsCutId3->GetBlockData(block);
< 			int* pCutId4 = plsCutId4->GetBlockData(block);
< 			int* pCutId5 = plsCutId5->GetBlockData(block);
< 
777,780d949
< #ifdef _LARGE_BLOCK_
< //#pragma omp parallel for reduction(+: nCellsChanged)
< #else
< #endif
785,798d953
< 						int mw = i-1 + nc[0]*( j + nc[1]*k );
< 						int me = i+1 + nc[0]*( j + nc[1]*k );
< 						int ms = i + nc[0]*( j-1 + nc[1]*k );
< 						int mn = i + nc[0]*( j+1 + nc[1]*k );
< 						int mb = i + nc[0]*( j + nc[1]*(k-1) );
< 						int mt = i + nc[0]*( j + nc[1]*(k+1) );
< 
< 						int cidp0 = pCutId0[mp];
< 						int cidp1 = pCutId1[mp];
< 						int cidp2 = pCutId2[mp];
< 						int cidp3 = pCutId3[mp];
< 						int cidp4 = pCutId4[mp];
< 						int cidp5 = pCutId5[mp];
< 
800,826c955,957
< 							continue;
< 						}
< //						std::cout << i << " " << j << " " << k << " " << pPhaseId[mp] << std::endl;
< 
< 						if( (pPhaseId[mw] == 1 && cidp0 == 0) ||
< 								(pPhaseId[me] == 1 && cidp1 == 0) ||
< 								(pPhaseId[ms] == 1 && cidp2 == 0) ||
< 								(pPhaseId[mn] == 1 && cidp3 == 0) ||
< 								(pPhaseId[mb] == 1 && cidp4 == 0) ||
< 								(pPhaseId[mt] == 1 && cidp5 == 0) ) {
< 							pPhaseId[mp] = 1;
< 							nCellsChanged++;
< 
< /*
< 						if( rank==0 ) {
< 							std::cout << i << " ";
< 							std::cout << j << " ";
< 							std::cout << k << " ";
< 							std::cout << pPhaseId[mp] << " ";
< 							std::cout << pPhaseId[mw] << " ";
< 							std::cout << pPhaseId[me] << " ";
< 							std::cout << pPhaseId[ms] << " ";
< 							std::cout << pPhaseId[mn] << " ";
< 							std::cout << pPhaseId[mb] << " ";
< 							std::cout << pPhaseId[mt] << " ";
< 							std::cout << pPhaseId[mp] << " ";
< 							std::cout << std::endl;
---
> 							count++;
> 						} else {
> 							countS++;
828,869d958
< */
< 
< 						}
< 					}
< 				}
< 			}
< 		}
< 		plsPhaseId->ImposeBoundaryCondition(blockManager);
< 
< 		long int nCellsChangedTmp = nCellsChanged;
< 		MPI_Allreduce(&nCellsChangedTmp, &nCellsChanged, 1, MPI_LONG, MPI_SUM, MPI_COMM_WORLD);
< 
< 		nIterationCount++;
< 	}while(nCellsChanged>0);
< 
< 
< 
< 	long int count = 0;
< 	long int countS = 0;
< #ifdef _LARGE_BLOCK_
< #else
< #endif
< 	for (int n=0; n<blockManager.getNumBlock(); ++n) {
< 		BlockBase* block = blockManager.getBlock(n);
< 		::Vec3i size = block->getSize();
< 		::Vec3r origin = block->getOrigin();
< 		::Vec3r blockSize = block->getBlockSize();
< 		::Vec3r cellSize = block->getCellSize();
< 
< 		int sz[3] = {size.x, size.y, size.z};
< 		int g[1] = {vc};
< 		int nc[3] = {size.x + 2*vc, size.y + 2*vc, size.z + 2*vc};
< 
< 		int* pPhaseId = plsPhaseId->GetBlockData(block);
< 		for(int k=vc; k<=size.z+vc-1; k++) {
< 			for(int j=vc; j<=size.y+vc-1; j++) {
< 				for(int i=vc; i<=size.x+vc-1; i++) {
< 					int mp = i + nc[0]*( j + nc[1]*k );
< 					if( pPhaseId[mp] > 0 ) {
< 						count++;
< 					} else {
< 						countS++;
874d962
< 	}
876,877c964,965
< 	long int countTmp = count;
< 	MPI_Allreduce(&countTmp, &count, 1, MPI_LONG, MPI_SUM, MPI_COMM_WORLD);
---
> 		long int countTmp = count;
> 		MPI_Allreduce(&countTmp, &count, 1, MPI_LONG_LONG_INT, MPI_SUM, MPI_COMM_WORLD);
879,880c967,968
< 	countTmp = countS;
< 	MPI_Allreduce(&countTmp, &countS, 1, MPI_LONG, MPI_SUM, MPI_COMM_WORLD);
---
> 		countTmp = countS;
> 		MPI_Allreduce(&countTmp, &countS, 1, MPI_LONG_LONG_INT, MPI_SUM, MPI_COMM_WORLD);
882,885c970,972
< 	if( rank==0 ) {
< 		std::cout << "# of interation for FILLING = " << nIterationCount << std::endl;
< 		std::cout << "# of FLUID cells = " << count << std::endl;
< 		std::cout << "# of SOLID cells = " << countS << std::endl;
---
> 		PrintLog(2, "%-20s : %d", "Iteration", nIterationCount);
> 		PrintLog(2, "%-20s : %d", "FLUID cells", count);
> 		PrintLog(2, "%-20s : %d", "SOLID cells", countS);
887d973
< 
891d976
< 
901c986
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
946,947c1031,1032
< 	plsUX0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUX, boundaryValueUX);
< 	plsUX1 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUX, boundaryValueUX);
---
> 	plsUX0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUX, boundaryValueUX, 1);
> 	plsUX1 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUX, boundaryValueUX, 1);
951,958c1036,1037
< 	plsUX0->Fill(blockManager, 0.0);
< 	plsUX1->Fill(blockManager, 0.0);
< /*
< 	if( conf.boundaryTypeUX_X_M == 0 && fabs(conf.boundaryValueUX_X_M) > 1.0e-3 ) {
< 		plsUX0->Fill(blockManager, conf.boundaryValueUX_X_M);
< 		plsUX1->Fill(blockManager, conf.boundaryValueUX_X_M);
< 	}
< */
---
> 	plsUX0->Fill(blockManager, 0.0, conf.uxs0);
> 	plsUX1->Fill(blockManager, 0.0, conf.uxs0);
984,985c1063,1064
< 	plsUY0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUY, boundaryValueUY);
< 	plsUY1 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUY, boundaryValueUY);
---
> 	plsUY0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUY, boundaryValueUY, 1);
> 	plsUY1 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUY, boundaryValueUY, 1);
989,990c1068,1069
< 	plsUY0->Fill(blockManager, 0.0);
< 	plsUY1->Fill(blockManager, 0.0);
---
> 	plsUY0->Fill(blockManager, 0.0, conf.uys0);
> 	plsUY1->Fill(blockManager, 0.0, conf.uys0);
1016,1017c1095,1096
< 	plsUZ0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUZ, boundaryValueUZ);
< 	plsUZ1 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUZ, boundaryValueUZ);
---
> 	plsUZ0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUZ, boundaryValueUZ, 1);
> 	plsUZ1 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeUZ, boundaryValueUZ, 1);
1021,1022c1100,1101
< 	plsUZ0->Fill(blockManager, 0.0);
< 	plsUZ1->Fill(blockManager, 0.0);
---
> 	plsUZ0->Fill(blockManager, 0.0, conf.uzs0);
> 	plsUZ1->Fill(blockManager, 0.0, conf.uzs0);
1067,1068c1146,1147
< 	plsT0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeT, boundaryValueT);
< 	plsT1 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeT, boundaryValueT);
---
> 	plsT0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeT, boundaryValueT, 1);
> 	plsT1 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeT, boundaryValueT, 1);
1099,1100c1178,1179
< 	plsP0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeP, boundaryValueP);
< 	plsPD = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeP, boundaryValueP);
---
> 	plsP0 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeP, boundaryValueP, 1);
> 	plsP1 = new LocalScalar3D<real>(blockManager, vc, conf.updateMethod, boundaryTypeP, boundaryValueP, 1);
1103c1182
< 	plsPD->Fill(blockManager, 0.0);
---
> 	plsP1->Fill(blockManager, 0.0);
1106c1185
< 	plsPD->ImposeBoundaryCondition(blockManager);
---
> 	plsP1->ImposeBoundaryCondition(blockManager);
1150a1230,1238
> 	if( conf.PLOT3DSave ) {
> 		WriteXYZInPlot3DFormat(
> 					"xyz",
> 					diffLevel,
> 					rootGrid,
> 					tree,
> 					partition,
> 					conf);
> 	}
1153a1242
> 	PrintLog(1, "Printing STL files for cut info");
1155,1157c1244,1246
< 	if( rank==0 ) {
< 		std::cout << "print cut completed" << std::endl;
< 	}
---
> 
> 	MPI_Barrier(MPI_COMM_WORLD);
> 	PrintLog(1, "Completed");
1168c1257
< 		Print(0, 0);
---
> 		Print(0);
1175d1263
< 		double t0 = GetTime();
1177,1182d1264
< 		double t1 = GetTime();
< 
< 		double time0 = t1 - t0;
< 		double times[1] = {
< 			time0,
< 		};
1184c1266
< 		Print(step, times);
---
> 		Print(step);
1201c1283
< int Solver::Print(int step, double* times) {
---
> int Solver::Print(int step) {
1203,1205c1285
< 		if( times ) {
< 			PrintTime(step, times);
< 		}
---
> 		PrintTime(step);
1208a1289
> 		PrintILS(step);
1223,1250c1304,1306
< void Solver::PrintTime(int step, double* times) {
< 	if( rank == 0 ) {
< 		std::cout << step;
< 		std::cout << " ";
< 		std::cout << times[0];
< 		std::cout << " ";
< 		std::cout << times[1];
< 		std::cout << " ";
< 		std::cout << this->countUX;
< 		std::cout << " ";
< 		std::cout << this->residualUX;
< 		std::cout << " ";
< 		std::cout << this->countUY;
< 		std::cout << " ";
< 		std::cout << this->residualUY;
< 		std::cout << " ";
< 		std::cout << this->countUZ;
< 		std::cout << " ";
< 		std::cout << this->residualUZ;
< 		std::cout << " ";
< 		std::cout << this->countP;
< 		std::cout << " ";
< 		std::cout << this->residualP;
< 		std::cout << " ";
< 		std::cout << this->countT;
< 		std::cout << " ";
< 		std::cout << this->residualT;
< 		std::cout << std::endl;
---
> void Solver::PrintTime(int step) {
> 	if( myrank != 0 ) {
> 		return;
1251a1308,1378
> 
> 	ostringstream ossMessage;
> 	ossMessage.width(10);
> 	ossMessage.setf(std::ios::fixed);
> 	ossMessage.fill('0');
> 	ossMessage << step << " ";
> 	ossMessage.setf(std::ios::scientific, std::ios::floatfield);
> 	ossMessage.precision(5);
> 	ossMessage << times[0];
> 	PrintLog(0, ossMessage.str().c_str());
> 
> 	std::string filename = "data-times.txt";
> 
> 	std::ofstream ofs;
> 	if( step==0 ) {
> 		ofs.open(filename.c_str(), std::ios::out);
> 		ofs.close();
> 	}
> 	ofs.open(filename.c_str(), std::ios::out | std::ios::app);
> 
> 	ofs.width(10);
> 	ofs.setf(std::ios::fixed);
> 	ofs.fill('0');
> 	ofs << step << " ";
> 
> 	ofs.setf(std::ios::scientific, std::ios::floatfield);
> 	ofs.precision(5);
> 	ofs << this->times[0] << " ";
> 	ofs << this->times[1] << " ";
> 	ofs << this->times[2] << " ";
> 	ofs << this->times[3] << " ";
> 	ofs << this->times[4] << " ";
> 	ofs << this->times[5] << " ";
> 	ofs << this->times[6] << " ";
> 	ofs << std::endl;
> 	ofs.close();
> }
> 
> void Solver::PrintILS(int step) {
> 	if( myrank != 0 ) {
> 		return;
> 	}
> 
> 	std::string filename = "data-ils.txt";
> 
> 	std::ofstream ofs;
> 	if( step==0 ) {
> 		ofs.open(filename.c_str(), std::ios::out);
> 		ofs.close();
> 	}
> 	ofs.open(filename.c_str(), std::ios::out | std::ios::app);
> 
> 	ofs.width(10);
> 	ofs.setf(std::ios::fixed);
> 	ofs.fill('0');
> 	ofs << step << " ";
> 
> 	ofs.setf(std::ios::scientific, std::ios::floatfield);
> 	ofs.precision(5);
> 	ofs << this->countUX << " ";
> 	ofs << this->residualUX << " ";
> 	ofs << this->countUY << " ";
> 	ofs << this->residualUY << " ";
> 	ofs << this->countUZ << " ";
> 	ofs << this->residualUZ << " ";
> 	ofs << this->countP << " ";
> 	ofs << this->residualP << " ";
> 	ofs << this->countT << " ";
> 	ofs << this->residualT << " ";
> 	ofs << std::endl;
> 	ofs.close();
1261c1388,1392
< 	if( rank != 0 ) {
---
> 	if( plsUX0->GetAbsMaxL() > 100.0 ) {
> 		std::cout << myrank << std::endl;
> 	}
> 
> 	if( myrank != 0 ) {
1313c1444
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1399,1401c1530,1533
< 	double sum = fsp_local[0];
< 	double sum_tmp = sum;
< 	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
---
> 	real sum = fsp_local[0];
> 	real sum_tmp = sum;
> 	allreduce_(&sum, &sum_tmp);
> //	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
1406c1538,1539
< 	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
---
> 	allreduce_(&sum, &sum_tmp);
> //	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
1411c1544,1545
< 	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
---
> 	allreduce_(&sum, &sum_tmp);
> //	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
1416c1550,1551
< 	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
---
> 	allreduce_(&sum, &sum_tmp);
> //	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
1421c1556,1557
< 	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
---
> 	allreduce_(&sum, &sum_tmp);
> //	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
1426c1562,1563
< 	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
---
> 	allreduce_(&sum, &sum_tmp);
> //	MPI_Allreduce(&sum_tmp, &sum, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_WORLD);
1429c1566
< 	if( rank != 0 ) {
---
> 	if( myrank != 0 ) {
1460a1598,1600
> 	if( conf.PLOT3DSave ) {
> 		WriteDataInPlot3DFormat("flow", step, diffLevel, rootGrid, tree, partition, conf);
> 	}
1467a1608,1655
> void Solver::PrintLog(int level, const char* format, ...) {
> 	if( myrank != 0 ) {
> 		return;
> 	}
> 	static int first = 1;
> 
> 	va_list ap;
> 	va_start(ap, format);
> 
> 	char* buffer;
> 	int size = vasprintf(&buffer, format, ap);
> 	va_end(ap);
> 
> 	ostringstream ossMessage;
> 	switch(level) {
> 		case 1:
> 			ossMessage << "# ";
> 			break;
> 		case 2:
> 			ossMessage << "#   ";
> 			break;
> 		case 3:
> 			ossMessage << "#     ";
> 			break;
> 		case 0:
> 		default:
> 			break;
> 	}
> 	ossMessage << string(buffer);
> 
> 
> 	free(buffer);
> 
> 	std::cout << ossMessage.str() << std::endl;
> 
> 	std::string filename = "data-log.txt";
> 	std::ofstream ofs;
> 	if( first == 1 ) {
> 		ofs.open(filename.c_str(), std::ios::out);
> 		ofs.close();
> 	}
> 	ofs.open(filename.c_str(), std::ios::out | std::ios::app);
> 	ofs << ossMessage.str() << std::endl;
> 	ofs.close();
> 
> 	first = 0;
> }
> 
1468a1657,1670
> 	g_pPM->gather();
> 
> 	if( this->myrank == 0 ) {
> 		char hostname[MPI_MAX_PROCESSOR_NAME] = {0};
> 		int nameLen;
> 		MPI_Get_processor_name(hostname, &nameLen);
> 		nameLen++;
> 
> 		FILE* fp = fopen("data-pm.txt", "w");
> 		g_pPM->print(fp, hostname, conf.operatorname);
> 		g_pPM->printDetail(fp);
> 		fclose(fp);
> 	}
> 
1472a1675,1676
> PM_Start(tm_Update, 0, 0, true);
> double t0 = GetTime();
1480c1684,1689
< 	UpdateT();
---
> PM_Start(tm_UpdateT, 0, 0, true);
> 	if( conf.bHeat ) {
> 		UpdateT();
> 	}
> double t1 = GetTime();
> PM_Stop(tm_UpdateT);
1481a1691
> PM_Start(tm_UpdateUX, 0, 0, true);
1482a1693,1696
> PM_Stop(tm_UpdateUX);
> double t2 = GetTime();
> 
> PM_Start(tm_UpdateUY, 0, 0, true);
1483a1698,1701
> PM_Stop(tm_UpdateUY);
> double t3 = GetTime();
> 
> PM_Start(tm_UpdateUZ, 0, 0, true);
1484a1703,1706
> PM_Stop(tm_UpdateUZ);
> double t4 = GetTime();
> 
> PM_Start(tm_UpdateP, 0, 0, true);
1485a1708,1711
> PM_Stop(tm_UpdateP);
> double t5 = GetTime();
> 
> PM_Start(tm_UpdateU, 0, 0, true);
1486a1713,1724
> PM_Stop(tm_UpdateU);
> double t6 = GetTime();
> 
> PM_Stop(tm_Update);
> 
> 	this->times[0] = t6 - t0;
> 	this->times[1] = t1 - t0;
> 	this->times[2] = t2 - t1;
> 	this->times[3] = t3 - t2;
> 	this->times[4] = t4 - t3;
> 	this->times[5] = t5 - t4;
> 	this->times[6] = t6 - t5;
1492c1730
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1609a1848,1850
> 		real gx = conf.gx;
> 		real gy = conf.gy;
> 		real gz = conf.gz;
1623a1865
> 				&gx, &gy, &gz,
1631,1689c1873,1948
< #ifdef _LARGE_BLOCK_
< 	pils->BiCGSTAB(
< 						blockManager,
< 						plsUX0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						omegaU,
< 						countPreConditionerU,
< 						countMaxU,
< 						epsilonU,
< 						countUX,
< 						residualUX);
< #else
< 	pils->BiCGSTAB_Mask(
< 						blockManager,
< 						plsUX0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						plsMaskId,
< 						omegaU,
< 						countPreConditionerU,
< 						countMaxU,
< 						epsilonU,
< 						countUX,
< 						residualUX);
< #endif
< 	plsUX0->ImposeBoundaryCondition(blockManager);
< 	if( rank==0 ) {
< //		std::cout << this->countUX << " " << this->residualUX << std::endl;
---
> 
> 	if( g_pconf->masking == true ) {
> 		pils->BiCGSTAB_Mask(
> 							blockManager,
> 							plsUX0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsUX1,
> 							plsMaskId,
> 							omegaU,
> 							countPreConditionerU,
> 							countMaxU,
> 							epsilonU,
> 							countUX,
> 							residualUX);
> /*
> 		pils->Jacobi_Mask(
> 							blockManager,
> 							plsUX0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsUX1,
> 							plsMaskId,
> 							omegaU,
> 							countMaxU,
> 							epsilonU,
> 							countUX,
> 							residualUX);
> */
> 	} else {
> 		pils->BiCGSTAB(
> 							blockManager,
> 							plsUX0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsUX1,
> 							omegaU,
> 							countPreConditionerU,
> 							countMaxU,
> 							epsilonU,
> 							countUX,
> 							residualUX);
1690a1950
> 	plsUX0->ImposeBoundaryCondition(blockManager);
1695c1955
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1799a2060,2062
> 		real gx = conf.gx;
> 		real gy = conf.gy;
> 		real gz = conf.gz;
1813a2077
> 				&gx, &gy, &gz,
1821,1879c2085,2140
< #ifdef _LARGE_BLOCK_
< 	pils->BiCGSTAB(
< 						blockManager,
< 						plsUY0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						omegaU,
< 						countPreConditionerU,
< 						countMaxU,
< 						epsilonU,
< 						countUY,
< 						residualUY);
< #else
< 	pils->BiCGSTAB_Mask(
< 						blockManager,
< 						plsUY0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						plsMaskId,
< 						omegaU,
< 						countPreConditionerU,
< 						countMaxU,
< 						epsilonU,
< 						countUY,
< 						residualUY);
< #endif
< 	plsUY0->ImposeBoundaryCondition(blockManager);
< 	if( rank==0 ) {
< //		std::cout << this->countUY << " " << this->residualUY << std::endl;
---
> 
> 	if( g_pconf->masking == true ) {
> 		pils->BiCGSTAB_Mask(
> 							blockManager,
> 							plsUY0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsUY1,
> 							plsMaskId,
> 							omegaU,
> 							countPreConditionerU,
> 							countMaxU,
> 							epsilonU,
> 							countUY,
> 							residualUY);
> 	} else {
> 		pils->BiCGSTAB(
> 							blockManager,
> 							plsUY0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsUY1,
> 							omegaU,
> 							countPreConditionerU,
> 							countMaxU,
> 							epsilonU,
> 							countUY,
> 							residualUY);
1880a2142
> 	plsUY0->ImposeBoundaryCondition(blockManager);
1885c2147
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1989a2252,2254
> 		real gx = conf.gx;
> 		real gy = conf.gy;
> 		real gz = conf.gz;
2003a2269
> 				&gx, &gy, &gz,
2011,2069c2277,2332
< #ifdef _LARGE_BLOCK_
< 	pils->BiCGSTAB(
< 						blockManager,
< 						plsUZ0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						omegaU,
< 						countPreConditionerU,
< 						countMaxU,
< 						epsilonU,
< 						countUZ,
< 						residualUZ);
< #else
< 	pils->BiCGSTAB_Mask(
< 						blockManager,
< 						plsUZ0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						plsMaskId,
< 						omegaU,
< 						countPreConditionerU,
< 						countMaxU,
< 						epsilonU,
< 						countUZ,
< 						residualUZ);
< #endif
< 	plsUZ0->ImposeBoundaryCondition(blockManager);
< 	if( rank==0 ) {
< //		std::cout << this->countUZ << " " << this->residualUZ << std::endl;
---
> 
> 	if( g_pconf->masking == true ) {
> 		pils->BiCGSTAB_Mask(
> 							blockManager,
> 							plsUZ0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsUZ1,
> 							plsMaskId,
> 							omegaU,
> 							countPreConditionerU,
> 							countMaxU,
> 							epsilonU,
> 							countUZ,
> 							residualUZ);
> 	} else {
> 		pils->BiCGSTAB(
> 							blockManager,
> 							plsUZ0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsUZ1,
> 							omegaU,
> 							countPreConditionerU,
> 							countMaxU,
> 							epsilonU,
> 							countUZ,
> 							residualUZ);
2070a2334
> 	plsUZ0->ImposeBoundaryCondition(blockManager);
2078c2342
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2139a2404
> 
2144c2409
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2207a2473
> 
2210,2268c2476,2530
< #ifdef _LARGE_BLOCK_
< 	pils->BiCGSTAB(
< 						blockManager,
< 						plsP0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						omegaP,
< 						countPreConditionerP,
< 						countMaxP,
< 						epsilonP,
< 						countP,
< 						residualP);
< #else
< 	pils->BiCGSTAB_Mask(
< 						blockManager,
< 						plsP0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						plsMaskId,
< 						omegaP,
< 						countPreConditionerP,
< 						countMaxP,
< 						epsilonP,
< 						countP,
< 						residualP);
< #endif
< 	plsP0->ImposeBoundaryCondition(blockManager);
< 	if( rank==0 ) {
< //		std::cout << this->countP << " " << this->residualP << std::endl;
---
> 	if( g_pconf->masking == true ) {
> 		pils->BiCGSTAB_Mask(
> 							blockManager,
> 							plsP0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsP1,
> 							plsMaskId,
> 							omegaP,
> 							countPreConditionerP,
> 							countMaxP,
> 							epsilonP,
> 							countP,
> 							residualP);
> 	} else {
> 		pils->BiCGSTAB(
> 							blockManager,
> 							plsP0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsP1,
> 							omegaP,
> 							countPreConditionerP,
> 							countMaxP,
> 							epsilonP,
> 							countP,
> 							residualP);
2269a2532
> 	plsP0->ImposeBoundaryCondition(blockManager);
2274c2537
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2340c2603
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2494,2572c2757,2811
< /*
< 	pils->Jacobi(
< 						blockManager,
< 						plst1,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsx0,
< 						omegaT,
< 						countMaxT,
< 						epsilonT,
< 						countT,
< 						residualT);
< */
< 
< #ifdef _LARGE_BLOCK_
< 	pils->BiCGSTAB(
< 						blockManager,
< 						plsT0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						omegaT,
< 						countPreConditionerT,
< 						countMaxT,
< 						epsilonT,
< 						countT,
< 						residualT);
< #else
< 	pils->BiCGSTAB_Mask(
< 						blockManager,
< 						plsT0,
< 						plsAp,
< 						plsAw,
< 						plsAe,
< 						plsAs,
< 						plsAn,
< 						plsAb,
< 						plsAt,
< 						plsb,
< 						plsr,
< 						plsr0,
< 						plsp,
< 						plsp_,
< 						plsq_,
< 						plss,
< 						plss_,
< 						plst_,
< 						plsx0,
< 						plsMaskId,
< 						omegaT,
< 						countPreConditionerT,
< 						countMaxT,
< 						epsilonT,
< 						countT,
< 						residualT);
< #endif
< 	plsT0->ImposeBoundaryCondition(blockManager);
< 	if( rank==0 ) {
< //		std::cout << this->countT << " " << this->residualT << std::endl;
---
> 	if( g_pconf->masking == true ) {
> 		pils->BiCGSTAB_Mask(
> 							blockManager,
> 							plsT0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsT1,
> 							plsMaskId,
> 							omegaT,
> 							countPreConditionerT,
> 							countMaxT,
> 							epsilonT,
> 							countT,
> 							residualT);
> 	} else {
> 		pils->BiCGSTAB(
> 							blockManager,
> 							plsT0,
> 							plsAp,
> 							plsAw,
> 							plsAe,
> 							plsAs,
> 							plsAn,
> 							plsAb,
> 							plsAt,
> 							plsb,
> 							plsr,
> 							plsr0,
> 							plsp,
> 							plsp_,
> 							plsq_,
> 							plss,
> 							plss_,
> 							plst_,
> 							plsT1,
> 							omegaT,
> 							countPreConditionerT,
> 							countMaxT,
> 							epsilonT,
> 							countT,
> 							residualT);
2573a2813
> 	plsT0->ImposeBoundaryCondition(blockManager);
2606c2846
< 	ossFileName << rank;
---
> 	ossFileName << myrank;
2613c2853
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2840,2858c3080,3098
< 	plsUX0->Dump3(blockManager, step, "ux", partition, rank);
< 	plsUY0->Dump3(blockManager, step, "uy", partition, rank);
< 	plsUZ0->Dump3(blockManager, step, "uz", partition, rank);
< 
< 	plsP0->Dump3(blockManager, step, "p", partition, rank);
< 
< 	plsVw->Dump3(blockManager, step, "vw", partition, rank);
< 	plsVe->Dump3(blockManager, step, "ve", partition, rank);
< 	plsVs->Dump3(blockManager, step, "vs", partition, rank);
< 	plsVn->Dump3(blockManager, step, "vn", partition, rank);
< 	plsVb->Dump3(blockManager, step, "vb", partition, rank);
< 	plsVt->Dump3(blockManager, step, "vt", partition, rank);
< 
< 	plsT0->Dump3(blockManager, step, "t", partition, rank);
< 
< 	plsUXCP->Dump3(blockManager, step, "uxcp", partition, rank);
< 	plsUYCP->Dump3(blockManager, step, "uycp", partition, rank);
< 	plsUZCP->Dump3(blockManager, step, "uzcp", partition, rank);
< 	plsTCP->Dump3(blockManager, step, "tcp", partition, rank);
---
> 	plsUX0->Dump3(blockManager, step, "ux", partition, myrank);
> 	plsUY0->Dump3(blockManager, step, "uy", partition, myrank);
> 	plsUZ0->Dump3(blockManager, step, "uz", partition, myrank);
> 
> 	plsP0->Dump3(blockManager, step, "p", partition, myrank);
> 
> 	plsVw->Dump3(blockManager, step, "vw", partition, myrank);
> 	plsVe->Dump3(blockManager, step, "ve", partition, myrank);
> 	plsVs->Dump3(blockManager, step, "vs", partition, myrank);
> 	plsVn->Dump3(blockManager, step, "vn", partition, myrank);
> 	plsVb->Dump3(blockManager, step, "vb", partition, myrank);
> 	plsVt->Dump3(blockManager, step, "vt", partition, myrank);
> 
> 	plsT0->Dump3(blockManager, step, "t", partition, myrank);
> 
> 	plsUXCP->Dump3(blockManager, step, "uxcp", partition, myrank);
> 	plsUYCP->Dump3(blockManager, step, "uycp", partition, myrank);
> 	plsUZCP->Dump3(blockManager, step, "uzcp", partition, myrank);
> 	plsTCP->Dump3(blockManager, step, "tcp", partition, myrank);
2862,2880c3102,3120
< 	plsUX0->Load3(blockManager, step, "ux", partition, rank);
< 	plsUY0->Load3(blockManager, step, "uy", partition, rank);
< 	plsUZ0->Load3(blockManager, step, "uz", partition, rank);
< 
< 	plsP0->Load3(blockManager, step, "p", partition, rank);
< 
< 	plsVw->Load3(blockManager, step, "vw", partition, rank);
< 	plsVe->Load3(blockManager, step, "ve", partition, rank);
< 	plsVs->Load3(blockManager, step, "vs", partition, rank);
< 	plsVn->Load3(blockManager, step, "vn", partition, rank);
< 	plsVb->Load3(blockManager, step, "vb", partition, rank);
< 	plsVt->Load3(blockManager, step, "vt", partition, rank);
< 
< 	plsT0->Load3(blockManager, step, "t", partition, rank);
< 
< 	plsUXCP->Load3(blockManager, step, "uxcp", partition, rank);
< 	plsUYCP->Load3(blockManager, step, "uycp", partition, rank);
< 	plsUZCP->Load3(blockManager, step, "uzcp", partition, rank);
< 	plsTCP->Load3(blockManager, step, "tcp", partition, rank);
---
> 	plsUX0->Load3(blockManager, step, "ux", partition, myrank);
> 	plsUY0->Load3(blockManager, step, "uy", partition, myrank);
> 	plsUZ0->Load3(blockManager, step, "uz", partition, myrank);
> 
> 	plsP0->Load3(blockManager, step, "p", partition, myrank);
> 
> 	plsVw->Load3(blockManager, step, "vw", partition, myrank);
> 	plsVe->Load3(blockManager, step, "ve", partition, myrank);
> 	plsVs->Load3(blockManager, step, "vs", partition, myrank);
> 	plsVn->Load3(blockManager, step, "vn", partition, myrank);
> 	plsVb->Load3(blockManager, step, "vb", partition, myrank);
> 	plsVt->Load3(blockManager, step, "vt", partition, myrank);
> 
> 	plsT0->Load3(blockManager, step, "t", partition, myrank);
> 
> 	plsUXCP->Load3(blockManager, step, "uxcp", partition, myrank);
> 	plsUYCP->Load3(blockManager, step, "uycp", partition, myrank);
> 	plsUZCP->Load3(blockManager, step, "uzcp", partition, myrank);
> 	plsTCP->Load3(blockManager, step, "tcp", partition, myrank);
diff -r BCMTools_20130417/examples/SolverTest/Solver.h BCMTools_20130709/examples/SolverTest/Solver.h
15a16,17
> #include "VtkWriter.h"
> #include "Plot3DWriter.h"
25c27
< 	int rank;
---
> 	int myrank;
27a30,31
> 	int maxLevel;
> 	int minLevel;
72c76
< 	LocalScalar3D<real> *plsPD;
---
> 	LocalScalar3D<real> *plsP1;
104,105d107
< 	LocalScalar3D<real> *plsx0;
< 
167,168c169,172
< 	int Print(int step, double* times);
< 	void PrintTime(int step, double* times);
---
> 	int Print(int step);
> 	double times[32];
> 	void PrintTime(int step);
> 	void PrintILS(int step);
171a176
> 	void PrintLog(int level, const char* format, ...);
202a208,223
> 		writer.writeVtkOverlappingAMR_PUT<real>(
> 						this->plsP0->GetID(),
> 						this->plsUX0->GetID(),
> 						this->plsUY0->GetID(),
> 						this->plsUZ0->GetID(),
> 						this->plsLapP->GetID(),
> 						this->vc,
> 						string(dataname),
> 						step,
> 						difflevel,
> 						rootGrid,
> 						tree,
> 						partition,
> 						conf.origin,
> 						conf.rootLength);
> 
237,238c258,289
< /*
< 		writer.writeVtkOverlappingAMR_PUT<real>(
---
> 	}
> 
> 	void WriteXYZInPlot3DFormat(
> 						const char* dataname,
> 						int difflevel,
> 						RootGrid* rootGrid,
> 						BCMOctree* tree,
> 						Partition* partition,
> 						Config& conf) {
> 		Plot3DWriter writer;
> 		writer.writeXYZ(
> 						this->plsPhaseId->GetID(),
> 						this->vc,
> 						string(dataname),
> 						difflevel,
> 						rootGrid,
> 						tree,
> 						partition,
> 						conf.origin,
> 						conf.rootLength);
> 	}
> 
> 	void WriteDataInPlot3DFormat(
> 						const char* dataname,
> 						int step,
> 						int difflevel,
> 						RootGrid* rootGrid,
> 						BCMOctree* tree,
> 						Partition* partition,
> 						Config& conf) {
> 		Plot3DWriter writer;
> 		writer.writeData<real>(
243d293
< 						this->plsLapP->GetID(),
253,254d302
< */
< 
256a305
> 
412a462,468
> 
> private:
> 	string GetSolverName() {
> 		ostringstream ossSolverName;
> 		ossSolverName << "FFV-BCM(alpha)";
> 		return ossSolverName.str();
> 	}
BCMTools_20130417/examples/SolverTest のみに存在: Solver.o
BCMTools_20130709/examples/SolverTest のみに存在: SphereDivider2.h
BCMTools_20130709/examples/SolverTest のみに存在: SphereDivider3.h
BCMTools_20130417/examples/SolverTest のみに存在: Timing.o
BCMTools_20130709/examples/SolverTest のみに存在: VtkWriter.h
diff -r BCMTools_20130417/examples/SolverTest/bca.f90 BCMTools_20130709/examples/SolverTest/bca.f90
14c14
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
26c26
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
46c46
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
58c58
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
78c78
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
90c90
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
110c110
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
122c122
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
142c142
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
154c154
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
174c174
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
186c186
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
206c206
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
218c218
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
238c238
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
250c250
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
270c270
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
282c282
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
302c302
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
314c314
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
334c334
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
346c346
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
366c366
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
378c378
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
BCMTools_20130417/examples/SolverTest のみに存在: bca.o
diff -r BCMTools_20130417/examples/SolverTest/bcax.f90 BCMTools_20130709/examples/SolverTest/bcax.f90
1c1
< function bc_get_u(x0, y0, z0, um)
---
> function bc_get_u(x0, x1, um)
4,5c4,5
< 	real					:: x0, y0, z0
< 	real					:: x1, y1, z1
---
> 	real, dimension(3)	:: x0
> 	real, dimension(3)	:: x1
12,14c12,14
< 	x1 = x0
< 	y1 = 0.0
< 	z1 = 0.0
---
> !	x1 = x0
> !	y1 = 0.0
> !	z1 = 0.0
17,23c17,23
< 	x1 = x0
< 	y1 = 0.0
< 	z1 = -3.0
< 
< 	rx = x0 - x1
< 	ry = y0 - y1
< 	rz = z0 - z1
---
> !	x1 = x0
> !	y1 = 0.0
> !	z1 = -3.0
> 
> 	rx = x0(1) - x0(1)
> 	ry = x0(2) - x1(2)
> 	rz = x0(3) - x1(3)
36c36
< function bc_get_gp(x0, y0, z0, gp)
---
> function bc_get_gp(x0, x1, gp)
39,40c39,40
< 	real					:: x0, y0, z0
< 	real					:: x1, y1, z1
---
> 	real, dimension(3)	:: x0
> 	real, dimension(3)	:: x1
46,48c46,48
< 	x1 = x0
< 	y1 = 0.0
< 	z1 = 0.0
---
> !	x1 = x0
> !	y1 = 0.0
> !	z1 = 0.0
51,57c51,57
< 	x1 = x0
< 	y1 = 0.0
< 	z1 = -3.0
< 
< 	rx = x0 - x1
< 	ry = y0 - y1
< 	rz = z0 - z1
---
> !	x1 = x0
> !	y1 = 0.0
> !	z1 = -3.0
> 
> 	rx = x0(1) - x0(1)
> 	ry = x0(2) - x1(2)
> 	rz = x0(3) - x1(3)
69c69
< subroutine bc_x3_poiseuille_u(x, xc, sz, g, org, bsize, csize)
---
> subroutine bc_x3_poiseuille_u(x, xc, sz, g, center, org, bsize, csize)
74a75
> 	real, dimension(3)			:: center
79,81c80,81
< 	real										:: x0, y0, z0
< 	real										:: x1, y1, z1
< 	real										:: rx, ry, rz, r2, r
---
> 	real, dimension(3)			:: x0
> 	real, dimension(3)			:: x1
88c88,89
< #ifdef _LARGE_BLOCK_
---
> 	dx = csize(1)
> #ifdef _BLOCK_IS_LARGE_
90,93c91,92
< !$omp					 private(dx) &
< !$omp					 private(x0, y0, z0) &
< !$omp					 private(x1, y1, z1) &
< !$omp					 private(rx, ry, rz, r2, r) &
---
> !$omp					 private(x0) &
> !$omp					 private(x1) &
100,104c99,105
< 		dx = csize(1)
< 		x0 = org(1) + (real(i) - 0.5)*dx
< 		y0 = org(2) + (real(j) - 0.5)*dx
< 		z0 = org(3) + (real(k) - 0.5)*dx
< 		u = bc_get_u(x0, y0, z0, xc)
---
> 		x0(1) = org(1) + (real(i) - 0.5)*dx
> 		x0(2) = org(2) + (real(j) - 0.5)*dx
> 		x0(3) = org(3) + (real(k) - 0.5)*dx
> 		x1(1) = center(1)
> 		x1(2) = center(2)
> 		x1(3) = center(3)
> 		u = bc_get_u(x0, x1, xc)
109c110
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
116c117
< subroutine bc_Aw_poiseuille_u(Ap, Aw, b, xc, sz, g, org, bsize, csize)
---
> subroutine bc_Aw_poiseuille_u(Ap, Aw, b, xc, sz, g, center, org, bsize, csize)
121a123
> 	real, dimension(3)			:: center
127,129c129,130
< 	real										:: x0, y0, z0
< 	real										:: x1, y1, z1
< 	real										:: rx, ry, rz, r2, r
---
> 	real, dimension(3)			:: x0
> 	real, dimension(3)			:: x1
136c137,138
< #ifdef _LARGE_BLOCK_
---
> 	dx = csize(1)
> #ifdef _BLOCK_IS_LARGE_
138,141c140,141
< !$omp					 private(dx) &
< !$omp					 private(x0, y0, z0) &
< !$omp					 private(x1, y1, z1) &
< !$omp					 private(rx, ry, rz, r2, r) &
---
> !$omp					 private(x0) &
> !$omp					 private(x1) &
148,152c148,154
< 		dx = csize(1)
< 		x0 = org(1) + (real(i) - 0.5)*dx
< 		y0 = org(2) + (real(j) - 0.5)*dx
< 		z0 = org(3) + (real(k) - 0.5)*dx
< 		u = bc_get_u(x0, y0, z0, xc)
---
> 		x0(1) = org(1) + (real(i) - 0.5)*dx
> 		x0(2) = org(2) + (real(j) - 0.5)*dx
> 		x0(3) = org(3) + (real(k) - 0.5)*dx
> 		x1(1) = center(1)
> 		x1(2) = center(2)
> 		x1(3) = center(3)
> 		u = bc_get_u(x0, x1, xc)
158c160
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
165c167
< subroutine bc_x3_poiseuille_p(x, xc, sz, g, org, bsize, csize)
---
> subroutine bc_x3_poiseuille_p(x, xc, sz, g, center, org, bsize, csize)
170a173
> 	real, dimension(3)			:: center
175,177c178,179
< 	real										:: x0, y0, z0
< 	real										:: x1, y1, z1
< 	real										:: rx, ry, rz, r2, r
---
> 	real, dimension(3)			:: x0
> 	real, dimension(3)			:: x1
184c186,187
< #ifdef _LARGE_BLOCK_
---
> 	dx = csize(1)
> #ifdef _BLOCK_IS_LARGE_
186,189c189,191
< !$omp					 private(dx) &
< !$omp					 private(x0, y0, z0) &
< !$omp					 private(x1, y1, z1) &
< !$omp					 private(rx, ry, rz, r2, r) 
---
> !$omp					 private(x0) &
> !$omp					 private(x1) &
> !$omp					 private(gp) 
195,199c197,203
< 		dx = csize(1)
< 		x0 = org(1) + (real(i) - 0.5)*dx
< 		y0 = org(2) + (real(j) - 0.5)*dx
< 		z0 = org(3) + (real(k) - 0.5)*dx
< 		gp = bc_get_gp(x0, y0, z0, xc*dx)
---
> 		x0(1) = org(1) + (real(i) - 0.5)*dx
> 		x0(2) = org(2) + (real(j) - 0.5)*dx
> 		x0(3) = org(3) + (real(k) - 0.5)*dx
> 		x1(1) = center(1)
> 		x1(2) = center(2)
> 		x1(3) = center(3)
> 		gp = bc_get_gp(x0, x1, xc*dx)
204c208
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
211c215
< subroutine bc_Aw_poiseuille_p(Ap, Aw, b, xc, sz, g, org, bsize, csize)
---
> subroutine bc_Aw_poiseuille_p(Ap, Aw, b, xc, sz, g, center, org, bsize, csize)
216a221
> 	real, dimension(3)			:: center
222,224c227,228
< 	real										:: x0, y0, z0
< 	real										:: x1, y1, z1
< 	real										:: rx, ry, rz, r2, r
---
> 	real, dimension(3)			:: x0
> 	real, dimension(3)			:: x1
231c235,236
< #ifdef _LARGE_BLOCK_
---
> 	dx = csize(1)
> #ifdef _BLOCK_IS_LARGE_
233,236c238,240
< !$omp					 private(dx) &
< !$omp					 private(x0, y0, z0) &
< !$omp					 private(x1, y1, z1) &
< !$omp					 private(rx, ry, rz, r2, r) 
---
> !$omp					 private(x0) &
> !$omp					 private(x1) &
> !$omp					 private(gp) 
242,246c246,252
< 		dx = csize(1)
< 		x0 = org(1) + (real(i) - 0.5)*dx
< 		y0 = org(2) + (real(j) - 0.5)*dx
< 		z0 = org(3) + (real(k) - 0.5)*dx
< 		gp = bc_get_gp(x0, y0, z0, xc*dx)
---
> 		x0(1) = org(1) + (real(i) - 0.5)*dx
> 		x0(2) = org(2) + (real(j) - 0.5)*dx
> 		x0(3) = org(3) + (real(k) - 0.5)*dx
> 		x1(1) = center(1)
> 		x1(2) = center(2)
> 		x1(3) = center(3)
> 		gp = bc_get_gp(x0, x1, xc*dx)
252c258
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
diff -r BCMTools_20130417/examples/SolverTest/bcax.h BCMTools_20130709/examples/SolverTest/bcax.h
9a10
> 				, double *center
17a19
> 					double *center,
22a25
> 				, double *center
30a34
> 					double *center,
BCMTools_20130417/examples/SolverTest のみに存在: bcax.o
diff -r BCMTools_20130417/examples/SolverTest/bcut.f90 BCMTools_20130709/examples/SolverTest/bcut.f90
87c87
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
238c238
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
289c289
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
503c503
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
556c556
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
786c786
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
837c837
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
985c985
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1038c1038
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1186c1186
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1229c1229
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1352c1352
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1397c1397
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1517c1517
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1561c1561
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1683c1683
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1737c1737
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1938c1938
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1958a1959
> 								gx, gy, gz, &
1980a1982
> 	real										:: gx, gy, gz
1993c1995
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2055,2060c2057,2062
< 		rdpx0 = r0*dpx0
< 		rdpx1 = r1*dpx1
< 		rdpy2 = r2*dpy2
< 		rdpy3 = r3*dpy3
< 		rdpz4 = r4*dpz4
< 		rdpz5 = r5*dpz5
---
> 		rdpx0 = r0*dpx0 + gx
> 		rdpx1 = r1*dpx1 + gx
> 		rdpy2 = r2*dpy2 + gy
> 		rdpy3 = r3*dpy3 + gy
> 		rdpz4 = r4*dpz4 + gz
> 		rdpz5 = r5*dpz5 + gz
2202c2204
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2257c2259
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2465c2467
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2506c2508
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2649c2651
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2693c2695
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2856,2862c2858,2864
< 			Ap(i, j, k) = 1.0d0
< 			Aw(i, j, k) = 0.0d0
< 			Ae(i, j, k) = 0.0d0
< 			As(i, j, k) = 0.0d0
< 			An(i, j, k) = 0.0d0
< 			Ab(i, j, k) = 0.0d0
< 			At(i, j, k) = 0.0d0
---
> 			Ap(i, j, k) =-6.0d0
> 			Aw(i, j, k) = 1.0d0
> 			Ae(i, j, k) = 1.0d0
> 			As(i, j, k) = 1.0d0
> 			An(i, j, k) = 1.0d0
> 			Ab(i, j, k) = 1.0d0
> 			At(i, j, k) = 1.0d0
2875c2877
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2920c2922
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3112c3114
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3158c3160
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3279c3281
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3327c3329
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3416,3432c3418,3434
< 		Ap(i, j, k) = 1.0d0 + (l0 + l1) &
< 												+ (l2 + l3) &
< 												+ (l4 + l5)
< 		Aw(i, j, k) = -l0*(1.0d0 - m0)
< 		Ae(i, j, k) = -l1*(1.0d0 - m1)
< 		As(i, j, k) = -l2*(1.0d0 - m2)
< 		An(i, j, k) = -l3*(1.0d0 - m3)
< 		Ab(i, j, k) = -l4*(1.0d0 - m4)
< 		At(i, j, k) = -l5*(1.0d0 - m5)
< 		 b(i, j, k) = t0_(i, j, k) &
< 									+ l0*Tc*m0 &
< 									+ l1*Tc*m1 &
< 									+ l2*Tc*m2 &
< 									+ l3*Tc*m3 &
< 									+ l4*Tc*m4 &
< 									+ l5*Tc*m5 &
< 									- (1.5d0*tc0_(i, j, k) - 0.5d0*tcp_(i, j, k))*dt 
---
> !		Ap(i, j, k) = 1.0d0 + (l0 + l1) &
> !												+ (l2 + l3) &
> !												+ (l4 + l5)
> !		Aw(i, j, k) = -l0*(1.0d0 - m0)
> !		Ae(i, j, k) = -l1*(1.0d0 - m1)
> !		As(i, j, k) = -l2*(1.0d0 - m2)
> !		An(i, j, k) = -l3*(1.0d0 - m3)
> !		Ab(i, j, k) = -l4*(1.0d0 - m4)
> !		At(i, j, k) = -l5*(1.0d0 - m5)
> !		 b(i, j, k) = t0_(i, j, k) &
> !									+ l0*Tc*m0 &
> !									+ l1*Tc*m1 &
> !									+ l2*Tc*m2 &
> !									+ l3*Tc*m3 &
> !									+ l4*Tc*m4 &
> !									+ l5*Tc*m5 &
> !									- (1.5d0*tc0_(i, j, k) - 0.5d0*tcp_(i, j, k))*dt 
3467c3469
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3510c3512
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3660c3662
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3716c3718
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3873c3875
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
3927c3929
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
4071c4073
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
4080a4083,4224
> subroutine bcut_calc_q( &
> 								qx, &
> 								qy, &
> 								qz, &
> 								q, &
> 								t, &
> 								c0, c1, c2, c3, c4, c5, &
> 								cid0, cid1, cid2, cid3, cid4, cid5, &
> 								pid, &
> 								rhof, &
> 								cpf, &
> 								kf, &
> 								dx, dt, &
> 								Tc, &
> 								sz, g)
> 	implicit none
> 	integer									:: i, j, k
> 	integer									:: ix, jx, kx
> 	integer									:: g
> 	integer, dimension(3)		:: sz
> 	real, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g)	:: qx, qy, qz
> 	real, dimension(1:3)		:: q
> 	real, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g)	:: t
>   real, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g)  :: c0, c1, c2, c3, c4, c5
>   integer, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g)  :: cid0, cid1, cid2, cid3, cid4, cid5
>   integer, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g)  :: pid
> 	real										:: rhof
> 	real										:: cpf
> 	real										:: kf
>   real                    :: dx, dt
> 	real										:: Tc
> 	real										:: tp, tw, te, ts, tn, tb, tt
> 	integer									:: cidp
> 	integer									:: cidp0, cidp1, cidp2, cidp3, cidp4, cidp5
> 	integer									:: pidp, pidw, pide, pids, pidn, pidb, pidt
> 	real										:: d0, d1, d2, d3, d4, d5
> 	real										:: m0, m1, m2, m3, m4, m5
> 	real										:: qx0, qy0, qz0
> 	ix = sz(1)
> 	jx = sz(2)
> 	kx = sz(3)
> 	qx0 = 0.0
> 	qy0 = 0.0
> 	qz0 = 0.0
> #ifdef _BLOCK_IS_LARGE_
> !$omp parallel private(i, j, k) 
> !$omp do schedule(static, 1), &
> !$omp		 reduction(+:qx0, qy0, qz0)
> #else
> #endif
> 	do k=1, kx
> 	do j=1, jx
> !ocl nouxsimd
> 	do i=1, ix
> 		tp = t(i, j, k)
> 		tw = t(i-1, j, k)
> 		te = t(i+1, j, k)
> 		ts = t(i, j-1, k)
> 		tn = t(i, j+1, k)
> 		tb = t(i, j, k-1)
> 		tt = t(i, j, k+1)
> 
> 		m0 = 0.0d0
> 		m1 = 0.0d0
> 		m2 = 0.0d0
> 		m3 = 0.0d0
> 		m4 = 0.0d0
> 		m5 = 0.0d0
> 
> 		d0 = c0(i, j, k)
> 		d1 = c1(i, j, k)
> 		d2 = c2(i, j, k)
> 		d3 = c3(i, j, k)
> 		d4 = c4(i, j, k)
> 		d5 = c5(i, j, k)
> 
> 		cidp0 = cid0(i, j, k)
> 		cidp1 = cid1(i, j, k)
> 		cidp2 = cid2(i, j, k)
> 		cidp3 = cid3(i, j, k)
> 		cidp4 = cid4(i, j, k)
> 		cidp5 = cid5(i, j, k)
> 
> 		pidp = pid(i, j, k)
> 
> 		if( cidp0 /= 0 ) then
> 			tw  = (1.0d0 - 1.0d0/d0)*tp + (1.0d0/d0)*Tc
> 			m0 = 1.0d0
> 		endif
> 		if( cidp1 /= 0 ) then
> 			te  = (1.0d0 - 1.0d0/d1)*tp + (1.0d0/d1)*Tc
> 			m1 = 1.0d0
> 		endif
> 		if( cidp2 /= 0 ) then
> 			ts  = (1.0d0 - 1.0d0/d2)*tp + (1.0d0/d2)*Tc
> 			m2 = 1.0d0
> 		endif
> 		if( cidp3 /= 0 ) then
> 			tn  = (1.0d0 - 1.0d0/d3)*tp + (1.0d0/d3)*Tc
> 			m3 = 1.0d0
> 		endif
> 		if( cidp4 /= 0 ) then
> 			tb  = (1.0d0 - 1.0d0/d4)*tp + (1.0d0/d4)*Tc
> 			m4 = 1.0d0
> 		endif
> 		if( cidp5 /= 0 ) then
> 			tt  = (1.0d0 - 1.0d0/d5)*tp + (1.0d0/d5)*Tc
> 			m5 = 1.0d0
> 		endif
> 
> 		if( pidp /= 1 ) then
> 			m0 = 0.0d0
> 			m1 = 0.0d0
> 			m2 = 0.0d0
> 			m3 = 0.0d0
> 			m4 = 0.0d0
> 			m5 = 0.0d0
> 		endif
> 
> 		qx(i, j, k) = - kf*(tp - tw)/dx*m0 &
> 									+ kf*(te - tp)/dx*m1
> 		qy(i, j, k) = - kf*(tp - ts)/dx*m2 &
> 									+ kf*(tn - tp)/dx*m3
> 		qz(i, j, k) = - kf*(tp - tb)/dx*m4 &
> 									+ kf*(tt - tp)/dx*m5
> 
> 		qx0 = qx0 + qx(i, j, k)
> 		qy0 = qy0 + qy(i, j, k)
> 		qz0 = qz0 + qz(i, j, k)
> 	end do
> 	end do
> 	end do
> #ifdef _BLOCK_IS_LARGE_
> !$omp end do
> !$omp end parallel
> #else
> #endif
> 	q(1) = qx0
> 	q(2) = qy0
> 	q(3) = qz0
> end subroutine bcut_calc_q
> 
4112c4256
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
4139c4283
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
4167c4311
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
4198c4342
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
diff -r BCMTools_20130417/examples/SolverTest/bcut.h BCMTools_20130709/examples/SolverTest/bcut.h
107a108
> 				real* gx, real* gy, real* gz,
BCMTools_20130417/examples/SolverTest のみに存在: bcut.o
diff -r BCMTools_20130417/examples/SolverTest/bcx.f90 BCMTools_20130709/examples/SolverTest/bcx.f90
13c13
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
24c24
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
43c43
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
54c54
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
73c73
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
84c84
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
103c103
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
114c114
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
133c133
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
144c144
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
163c163
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
174c174
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
193c193
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
204c204
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
223c223
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
234c234
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
253c253
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
264c264
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
283c283
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
294c294
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
313c313
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
324c324
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
343c343
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
354c354
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
373c373
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
385c385
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
404c404
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
415c415
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
434c434
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
446c446
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
465c465
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
476c476
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
495c495
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
507c507
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
526c526
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
537c537
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
555c555
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
568c568
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
586c586
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
599c599
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
617c617
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
630c630
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
BCMTools_20130417/examples/SolverTest のみに存在: bcx.o
diff -r BCMTools_20130417/examples/SolverTest/blas.f90 BCMTools_20130709/examples/SolverTest/blas.f90
12c12
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
24c24
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
44c44
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
58c58
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
76c76
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
88c88
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
94a95,124
> subroutine copy_integer(y, x, sz, g)
> 	implicit none
> 	integer, dimension(3)		:: sz
> 	integer									:: g
> 	integer									:: i, j, k
> 	integer									:: ix, jx, kx
> 	integer, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g)	:: y
> 	integer, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g)	:: x
> 	ix = sz(1)
> 	jx = sz(2)
> 	kx = sz(3)
> #ifdef _BLOCK_IS_LARGE_
> !$omp parallel private(i, j, k)
> !$omp do
> #else
> #endif
> 	do k=1-g, kx+g
> 	do j=1-g, jx+g
> 	do i=1-g, ix+g
> 		y(i, j, k) = x(i, j, k)
> 	end do
> 	end do
> 	end do
> #ifdef _BLOCK_IS_LARGE_
> !$omp end do
> !$omp end parallel
> #else
> #endif
> end subroutine copy_integer
> 
106c136
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
121c151
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
140c170
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
155c185
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
173c203
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
188c218
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
207c237
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
222c252
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
241c271
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
256c286
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
276c306
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
291c321
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
310c340
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
325c355
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
345c375
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
347c377
< !$omp do reduction(+:xy), schedule(dynamic,1)
---
> !$omp do reduction(+:xy)
360c390
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
382c412
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
384c414
< !$omp do reduction(+:xy,xz), schedule(dynamic,1)
---
> !$omp do reduction(+:xy,xz)
398c428
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
425c455
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
428c458
< !$omp do schedule(dynamic,1)
---
> !$omp do schedule(static,1)
450c480
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
477c507
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
480c510
< !$omp do schedule(dynamic,1)
---
> !$omp do schedule(static,1)
502c532
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
525c555
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
527c557
< !$omp do schedule(dynamic, 1) &
---
> !$omp do schedule(static, 1) &
548c578
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
573c603
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
575c605
< !$omp do schedule(dynamic, 1) &
---
> !$omp do schedule(static, 1) &
596c626
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
623c653
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
625c655
< !$omp do schedule(dynamic, 1) &
---
> !$omp do schedule(static, 1) &
646c676
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
667c697
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
680c710
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
686c716
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
699c729
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
892a923,927
> #ifdef _BLOCK_IS_LARGE_
> !$omp parallel private(ijk) &
> !$omp					 private(r, x_tmp)
> !$omp do 
> #else
895a931
> #endif
908a945,949
> #ifdef _BLOCK_IS_LARGE_
> !$omp end do
> !$omp end parallel
> #else
> #endif
909a951,975
> 
> subroutine copy_mask(y, x, mask, sz, g)
> 	implicit none
> 	integer									:: cx, cy, cz
> 	integer									:: ijk
> 	integer									:: ijk0, ijkx
> 	integer, dimension(3)		:: sz
> 	integer									:: g
> 	real, dimension(1:(sz(1)+2*g)*(sz(2)+2*g)*(sz(3)+2*g))	:: y
> 	real, dimension(1:(sz(1)+2*g)*(sz(2)+2*g)*(sz(3)+2*g))	:: x
> 	integer, dimension(1:(sz(1)+2*g)*(sz(2)+2*g)*(sz(3)+2*g))	:: mask
>   cx = sz(1) + 2*g
>   cy = sz(2) + 2*g
>   cz = sz(3) + 2*g
>   ijk0 = cx*cy*g + cx*g + g + 1
>   ijkx = cx*cy*cz - ijk0 + 1
> !ocl serial
> !ocl nouxsimd
> !dir$ simd
> 	do ijk=ijk0, ijkx
> 		if( mask(ijk) == 1 ) then	
>       y(ijk) = x(ijk)
>     end if
> 	end do
> end subroutine copy_mask
diff -r BCMTools_20130417/examples/SolverTest/blas.h BCMTools_20130709/examples/SolverTest/blas.h
20a21,23
> 	void copy_integer_(
> 					int *y, int *x
> 				, int *sz, int *g);
85c88,101
< 
---
> 	void copy_mask_(
> 					real *y, real *x,
> 					int* mask,
> 					int *sz, int *g);
> 	void dot_mask_(
> 					real *xy, real *y, real *x,
> 					int* mask,
> 					int *sz, int *g);
> 	void calc_ax_mask_( 
> 					real* Ax,
> 					real* Ap, real* Aw, real* Ae, real* As, real* An, real* Ab, real* At,
> 					real* x,
> 					int* mask,
> 					int* sz, int* g);
BCMTools_20130417/examples/SolverTest のみに存在: blas.o
BCMTools_20130709/examples/SolverTest のみに存在: bplt3d.f90
BCMTools_20130709/examples/SolverTest のみに存在: bplt3d.h
diff -r BCMTools_20130417/examples/SolverTest/bsf3d.f90 BCMTools_20130709/examples/SolverTest/bsf3d.f90
12c12
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
24c24
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
43c43,48
< #ifdef _LARGE_BLOCK_
---
> 	dsum = 0.0
> 	dmax = ddata(1, 1, 1)
> 	dmin = ddata(1, 1, 1)
> 	dabsmax = abs(ddata(1, 1, 1))
> 	dabsmin = abs(ddata(1, 1, 1))
> #ifdef _BLOCK_IS_LARGE_
76c81
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
BCMTools_20130417/examples/SolverTest のみに存在: bsf3d.o
diff -r BCMTools_20130417/examples/SolverTest/bstl.f90 BCMTools_20130709/examples/SolverTest/bstl.f90
22c22
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
92c92
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
127c127
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
282c282
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
319c319
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
350c350
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
385c385
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
534c534
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
573c573
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
756c756
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
794c794
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1003c1003
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1031c1031
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1106c1106
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1141c1141
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1294c1294
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1331c1331
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1362c1362
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1397c1397
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1545c1545
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1584c1584
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1760c1760
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1770a1771
> 								bClose, &
1779a1781
> 	integer									:: bClose
1798c1800
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
1874,1877c1876,1881
< 				cidp0 = 1
< 				cidw1 = 1
< 				c0(i  , j, k) = 0.5
< 				c1(i-1, j, k) = 0.5
---
> 				if( bClose == 1 ) then
> 					cidp0 = 1
> 					cidw1 = 1
> 					c0(i  , j, k) = 0.5
> 					c1(i-1, j, k) = 0.5
> 				endif
1887,1890c1891,1896
< 				cidp1 = 1
< 				cide0 = 1
< 				c1(i  , j, k) = 0.5
< 				c0(i+1, j, k) = 0.5
---
> 				if( bClose == 1 ) then
> 					cidp1 = 1
> 					cide0 = 1
> 					c1(i  , j, k) = 0.5
> 					c0(i+1, j, k) = 0.5
> 				endif
1900,1903c1906,1911
< 				cidp2 = 1
< 				cids3 = 1
< 				c2(i, j  , k) = 0.5
< 				c3(i, j-1, k) = 0.5
---
> 				if( bClose == 1 ) then
> 					cidp2 = 1
> 					cids3 = 1
> 					c2(i, j  , k) = 0.5
> 					c3(i, j-1, k) = 0.5
> 				endif
1913,1916c1921,1926
< 				cidp3 = 1
< 				cidn2 = 1
< 				c3(i, j  , k) = 0.5
< 				c2(i, j+1, k) = 0.5
---
> 				if( bClose == 1 ) then
> 					cidp3 = 1
> 					cidn2 = 1
> 					c3(i, j  , k) = 0.5
> 					c2(i, j+1, k) = 0.5
> 				endif
1926,1929c1936,1941
< 				cidp4 = 1
< 				cidb5 = 1
< 				c4(i, j, k  ) = 0.5
< 				c5(i, j, k-1) = 0.5
---
> 				if( bClose == 1 ) then
> 					cidp4 = 1
> 					cidb5 = 1
> 					c4(i, j, k  ) = 0.5
> 					c5(i, j, k-1) = 0.5
> 				endif
1939,1942c1951,1956
< 				cidp5 = 1
< 				cidt4 = 1
< 				c5(i, j, k  ) = 0.5
< 				c4(i, j, k+1) = 0.5
---
> 				if( bClose == 1 ) then
> 					cidp5 = 1
> 					cidt4 = 1
> 					c5(i, j, k  ) = 0.5
> 					c4(i, j, k+1) = 0.5
> 				endif
1998c2012
< #ifdef _LARGE_BLOCK_
---
> #ifdef _BLOCK_IS_LARGE_
2003a2018,2269
> 
> subroutine bstl_fill_holes_v2( &
> 								c0, c1, c2, c3, c4, c5, &
> 								cid0, cid1, cid2, cid3, cid4, cid5, &
> 								n, &
> 								bClose, &
> 								sz, g)
>   implicit none
>   integer, dimension(3)   :: sz
>   integer                 :: g
>   integer                 :: i, j, k
>   integer                 :: ix, jx, kx
> 	real, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g)  :: c0, c1, c2, c3, c4, c5
> 	integer, dimension(1-g:sz(1)+g, 1-g:sz(2)+g, 1-g:sz(3)+g)  :: cid0, cid1, cid2, cid3, cid4, cid5
> 	integer									:: n
> 	integer									:: bClose
> 	integer									:: cidp
> 	integer									:: cidp0, cidp1, cidp2, cidp3, cidp4, cidp5
> 	integer									:: cidw
> 	integer									:: cidw0, cidw1, cidw2, cidw3, cidw4, cidw5
> 	integer									:: cide
> 	integer									:: cide0, cide1, cide2, cide3, cide4, cide5
> 	integer									:: cids
> 	integer									:: cids0, cids1, cids2, cids3, cids4, cids5
> 	integer									:: cidn
> 	integer									:: cidn0, cidn1, cidn2, cidn3, cidn4, cidn5
> 	integer									:: cidb
> 	integer									:: cidb0, cidb1, cidb2, cidb3, cidb4, cidb5
> 	integer									:: cidt
> 	integer									:: cidt0, cidt1, cidt2, cidt3, cidt4, cidt5
>   ix = sz(1)
>   jx = sz(2)
>   kx = sz(3)
> 	n = 0
> #ifdef _BLOCK_IS_LARGE_
> !$omp parallel private(i, j, k) &
> !$omp					 private(cidp) &
> !$omp					 private(cidp0, cidp1, cidp2, cidp3, cidp4, cidp5) &
> !$omp					 private(cidw) &
> !$omp					 private(cidw0, cidw1, cidw2, cidw3, cidw4, cidw5) &
> !$omp					 private(cide) &
> !$omp					 private(cide0, cide1, cide2, cide3, cide4, cide5) &
> !$omp					 private(cids) &
> !$omp					 private(cids0, cids1, cids2, cids3, cids4, cids5) &
> !$omp					 private(cidn) &
> !$omp					 private(cidn0, cidn1, cidn2, cidn3, cidn4, cidn5) &
> !$omp					 private(cidb) &
> !$omp					 private(cidb0, cidb1, cidb2, cidb3, cidb4, cidb5) &
> !$omp					 private(cidt) &
> !$omp					 private(cidt0, cidt1, cidt2, cidt3, cidt4, cidt5)
> !$omp do reduction(+: n)
> #else
> #endif
>   do k=1, kx
>   do j=1, jx
>   do i=1, ix
> 		cidp0 = cid0(i, j, k)
> 		cidp1 = cid1(i, j, k)
> 		cidp2 = cid2(i, j, k)
> 		cidp3 = cid3(i, j, k)
> 		cidp4 = cid4(i, j, k)
> 		cidp5 = cid5(i, j, k)
> 
> 		cidw0 = cid0(i-1, j, k)
> 		cidw1 = cid1(i-1, j, k)
> 		cidw2 = cid2(i-1, j, k)
> 		cidw3 = cid3(i-1, j, k)
> 		cidw4 = cid4(i-1, j, k)
> 		cidw5 = cid5(i-1, j, k)
> 
> 		cide0 = cid0(i+1, j, k)
> 		cide1 = cid1(i+1, j, k)
> 		cide2 = cid2(i+1, j, k)
> 		cide3 = cid3(i+1, j, k)
> 		cide4 = cid4(i+1, j, k)
> 		cide5 = cid5(i+1, j, k)
> 
> 		cids0 = cid0(i, j-1, k)
> 		cids1 = cid1(i, j-1, k)
> 		cids2 = cid2(i, j-1, k)
> 		cids3 = cid3(i, j-1, k)
> 		cids4 = cid4(i, j-1, k)
> 		cids5 = cid5(i, j-1, k)
> 
> 		cidn0 = cid0(i, j+1, k)
> 		cidn1 = cid1(i, j+1, k)
> 		cidn2 = cid2(i, j+1, k)
> 		cidn3 = cid3(i, j+1, k)
> 		cidn4 = cid4(i, j+1, k)
> 		cidn5 = cid5(i, j+1, k)
> 
> 		cidb0 = cid0(i, j, k-1)
> 		cidb1 = cid1(i, j, k-1)
> 		cidb2 = cid2(i, j, k-1)
> 		cidb3 = cid3(i, j, k-1)
> 		cidb4 = cid4(i, j, k-1)
> 		cidb5 = cid5(i, j, k-1)
> 
> 		cidt0 = cid0(i, j, k+1)
> 		cidt1 = cid1(i, j, k+1)
> 		cidt2 = cid2(i, j, k+1)
> 		cidt3 = cid3(i, j, k+1)
> 		cidt4 = cid4(i, j, k+1)
> 		cidt5 = cid5(i, j, k+1)
> 
> 		if( cidp0 == 0 ) then
> 			if( ( (cids0 /= 0 .or. cidp2 /=0 .or. cidw2 /=0) .and. &
> 					  (cidn0 /= 0 .or. cidp3 /=0 .or. cidw3 /=0) ) .or. &
> 					( (cidb0 /= 0 .or. cidp4 /=0 .or. cidw4 /=0) .and. &
> 					  (cidt0 /= 0 .or. cidp5 /=0 .or. cidw5 /=0) ) ) then
> 				if( bClose == 1 ) then
> 					cidp0 = 1
> 					cidw1 = 1
> 					c0(i  , j, k) = 0.5
> 					c1(i-1, j, k) = 0.5
> 				end if
> 				n = n + 1
> 			endif
> 		endif
> 
> 		if( cidp1 == 0 ) then
> 			if( ( (cids1 /= 0 .or. cidp2 /=0 .or. cide2 /=0) .and. &
> 					  (cidn1 /= 0 .or. cidp3 /=0 .or. cide3 /=0) ) .or. &
> 					( (cidb1 /= 0 .or. cidp4 /=0 .or. cide4 /=0) .and. &
> 					  (cidt1 /= 0 .or. cidp5 /=0 .or. cide5 /=0) ) ) then
> 				if( bClose == 1 ) then
> 					cidp1 = 1
> 					cide0 = 1
> 					c1(i  , j, k) = 0.5
> 					c0(i+1, j, k) = 0.5
> 				end if
> 				n = n + 1
> 			endif
> 		endif
> 
> 		if( cidp2 == 0 ) then
> 			if( ( (cidw2 /= 0 .or. cidp0 /=0 .or. cids0 /=0) .and. &
> 					  (cide2 /= 0 .or. cidp1 /=0 .or. cids1 /=0) ) .or. &
> 					( (cidb2 /= 0 .or. cidp4 /=0 .or. cids4 /=0) .and. &
> 					  (cidt2 /= 0 .or. cidp5 /=0 .or. cids5 /=0) ) ) then
> 				if( bClose == 1 ) then
> 					cidp2 = 1
> 					cids3 = 1
> 					c2(i, j  , k) = 0.5
> 					c3(i, j-1, k) = 0.5
> 				end if
> 				n = n + 1
> 			endif
> 		endif
> 
> 		if( cidp3 == 0 ) then
> 			if( ( (cidw3 /= 0 .or. cidp0 /=0 .or. cidn0 /=0) .and. &
> 					  (cide3 /= 0 .or. cidp1 /=0 .or. cidn1 /=0) ) .or. &
> 					( (cidb3 /= 0 .or. cidp4 /=0 .or. cidn4 /=0) .and. &
> 					  (cidt3 /= 0 .or. cidp5 /=0 .or. cidn5 /=0) ) ) then
> 				if( bClose == 1 ) then
> 					cidp3 = 1
> 					cidn2 = 1
> 					c3(i, j  , k) = 0.5
> 					c2(i, j+1, k) = 0.5
> 				end if
> 				n = n + 1
> 			endif
> 		endif
> 
> 		if( cidp4 == 0 ) then
> 			if( ( (cidw4 /= 0 .or. cidp0 /=0 .or. cidb0 /=0) .and. &
> 					  (cide4 /= 0 .or. cidp1 /=0 .or. cidb1 /=0) ) .or. &
> 					( (cids4 /= 0 .or. cidp2 /=0 .or. cidb2 /=0) .and. &
> 					  (cidn4 /= 0 .or. cidp3 /=0 .or. cidb3 /=0) ) ) then
> 				if( bClose == 1 ) then
> 					cidp4 = 1
> 					cidb5 = 1
> 					c4(i, j, k  ) = 0.5
> 					c5(i, j, k-1) = 0.5
> 				end if
> 				n = n + 1
> 			endif
> 		endif
> 
> 		if( cidp5 == 0 ) then
> 			if( ( (cidw5 /= 0 .or. cidp0 /=0 .or. cidt0 /=0) .and. &
> 					  (cide5 /= 0 .or. cidp1 /=0 .or. cidt1 /=0) ) .or. &
> 					( (cids5 /= 0 .or. cidp2 /=0 .or. cidt2 /=0) .and. &
> 					  (cidn5 /= 0 .or. cidp3 /=0 .or. cidt3 /=0) ) ) then
> 				if( bClose == 1 ) then
> 					cidp5 = 1
> 					cidt4 = 1
> 					c5(i, j, k  ) = 0.5
> 					c4(i, j, k+1) = 0.5
> 				end if
> 				n = n + 1
> 			endif
> 		endif
> 
> 		cid0(i, j, k) = cidp0
> 		cid1(i, j, k) = cidp1
> 		cid2(i, j, k) = cidp2
> 		cid3(i, j, k) = cidp3
> 		cid4(i, j, k) = cidp4
> 		cid5(i, j, k) = cidp5
> 
> 		cid0(i-1, j, k) = cidw0
> 		cid1(i-1, j, k) = cidw1
> 		cid2(i-1, j, k) = cidw2
> 		cid3(i-1, j, k) = cidw3
> 		cid4(i-1, j, k) = cidw4
> 		cid5(i-1, j, k) = cidw5
> 
> 		cid0(i+1, j, k) = cide0
> 		cid1(i+1, j, k) = cide1
> 		cid2(i+1, j, k) = cide2
> 		cid3(i+1, j, k) = cide3
> 		cid4(i+1, j, k) = cide4
> 		cid5(i+1, j, k) = cide5
> 
> 		cid0(i, j-1, k) = cids0
> 		cid1(i, j-1, k) = cids1
> 		cid2(i, j-1, k) = cids2
> 		cid3(i, j-1, k) = cids3
> 		cid4(i, j-1, k) = cids4
> 		cid5(i, j-1, k) = cids5
> 
> 		cid0(i, j+1, k) = cidn0
> 		cid1(i, j+1, k) = cidn1
> 		cid2(i, j+1, k) = cidn2
> 		cid3(i, j+1, k) = cidn3
> 		cid4(i, j+1, k) = cidn4
> 		cid5(i, j+1, k) = cidn5
> 
> 		cid0(i, j, k-1) = cidb0
> 		cid1(i, j, k-1) = cidb1
> 		cid2(i, j, k-1) = cidb2
> 		cid3(i, j, k-1) = cidb3
> 		cid4(i, j, k-1) = cidb4
> 		cid5(i, j, k-1) = cidb5
> 
> 		cid0(i, j, k+1) = cidt0
> 		cid1(i, j, k+1) = cidt1
> 		cid2(i, j, k+1) = cidt2
> 		cid3(i, j, k+1) = cidt3
> 		cid4(i, j, k+1) = cidt4
> 		cid5(i, j, k+1) = cidt5
>   end do
>   end do
>   end do
> #ifdef _BLOCK_IS_LARGE_
> !$omp end do
> !$omp end parallel
> #else
> #endif
> end subroutine bstl_fill_holes_v2
diff -r BCMTools_20130417/examples/SolverTest/bstl.h BCMTools_20130709/examples/SolverTest/bstl.h
65a66,72
> 				int* bClose,
> 				int *sz, int *g);
> 	void bstl_fill_holes_v2_(
> 				real* c0, real* c1, real* c2, real* c3, real* c4, real* c5,
> 				int* cid0, int* cid1, int* cid2, int* cid3, int* cid4, int* cid5,
> 				int* count,
> 				int* bClose,
67,68d73
< 
< 
BCMTools_20130417/examples/SolverTest のみに存在: bstl.o
BCMTools_20130709/examples/SolverTest のみに存在: cavity.conf
BCMTools_20130709/examples/SolverTest のみに存在: comm.f90
BCMTools_20130709/examples/SolverTest のみに存在: comm.h
BCMTools_20130709/examples/SolverTest のみに存在: gv.cpp
BCMTools_20130709/examples/SolverTest のみに存在: gv.h
diff -r BCMTools_20130417/examples/SolverTest/main.cpp BCMTools_20130709/examples/SolverTest/main.cpp
11,13d10
< 	mkdir("./VTI", 0755);
< 	mkdir("./BIN", 0755);
< 
16,17d12
< 	bool bResult = false;
< 
38c33,35
< 		case 1 : {
---
> 		case EX_FAILURE : {
> 			delete pSolver;
> 			return EX_SUCCESS;
51c48,50
< 		case 1 : {
---
> 		case EX_FAILURE : {
> 			delete pSolver;
> 			return EX_SUCCESS;
BCMTools_20130417/examples/SolverTest のみに存在: main.o
BCMTools_20130709/examples/SolverTest のみに存在: outputVtk.cpp
BCMTools_20130709/examples/SolverTest のみに存在: outputVtk.h
diff -r BCMTools_20130417/examples/SolverTest/sphere.conf BCMTools_20130709/examples/SolverTest/sphere.conf
10a11
> treeType = rectangle
11a13,27
> treeType = sphere
> 
> dividerOx = 0.5
> dividerOy = 0.5
> dividerOz = 0.5
> dividerR  = 0.0333333333333
> dividerDR = 0.0016666666666
> dividerX0 = 0.1
> dividerY0 = 0.3
> dividerZ0 = 0.0
> dividerX1 = 1.0
> dividerY1 = 0.7
> dividerZ1 = 0.3
> 
> polylibConfig = sphere.tpp
13d28
< polylibConfig = sphere.xml
14a30
> 
37c53
< StepPrintBin   = 100
---
> StepPrintBin   = 1000
57d72
< omegaP    = 0.666666666666666666
60,61d74
< epsilonP  = 1.0e-8
< epsilonP  = 1.0e-4
63d75
< countPreConditionerP = 4
75c87,96
< updateMethod = SeparateXYZ_SeparateLevelDiff
---
> #updateMethod = SeparateXYZ_SeparateLevelDiff
> 
> dt = 0.0000915527
> dx = 0.000915527
> 
> dt = 0.0029296875
> dx = 0.029296875
> 
> dt = 0.0014648437
> dx = 0.014648437
85a107,118
> mu    = 0.000976562 #Re=1024 d=0.03125
> mu    = 0.00390625  #Re=256  d=0.0625
> mu    = 0.015625    #Re=64   d=0.125
> mu    = 0.003333333 #Re=300  d=0.057735027
> mu    = 0.04        #Re=25   d=0.2
> mu    = 0.0001      #Re=10000  d=0.01
> mu    = 0.00001     #Re=100000  
> mu    = 0.000001    #Re=1000000  d=0.001
> mu    = 1.0         #Re=1    d=1.0
> mu    = 100.0       #Re=0.01 d=10.0
> mu    = 0.001       #Re=1000
> mu    = 0.005       #Re=200
89a123
> PLOT3DSave = true
BCMTools_20130709/examples/SolverTest のみに存在: sphere.tpp
BCMTools_20130417/examples/SolverTest のみに存在: sphere.xml
BCMTools_20130709/examples/SolverTest のみに存在: sup.f90
BCMTools_20130709/examples/SolverTest のみに存在: sup.h
BCMTools_20130417/examples のみに存在: SolverTest1
BCMTools_20130709/examples のみに存在: make_setting.fx
BCMTools_20130709/examples のみに存在: make_setting.gnu
BCMTools_20130709/examples のみに存在: make_setting.ibm
BCMTools_20130709/examples のみに存在: make_setting.intel
diff -r BCMTools_20130417/examples/sor1/Makefile BCMTools_20130709/examples/sor1/Makefile
4c4
< UTIL = ../util
---
> UTIL = ../../Utils
13c13
< CFLAGS = -I../../include -I$(UTIL)/include $(OPTIONS)
---
> CFLAGS += -I../../include -I$(UTIL)/include $(OPTIONS)
16c16
< LIBS = $(BCMLIB) 
---
> LIBS = $(BCMLIB) -lmpi -lmpi_cxx
diff -r BCMTools_20130417/examples/sor2/Makefile BCMTools_20130709/examples/sor2/Makefile
4c4
< UTIL = ../util
---
> UTIL = ../../Utils
13c13
< CFLAGS = -I../../include -I$(UTIL)/include $(SILO_INC) $(OPTIONS)
---
> CFLAGS += -I../../include -I$(UTIL)/include $(SILO_INC) $(OPTIONS)
16c16
< LIBS = $(BCMLIB) $(SILO_LIB) 
---
> LIBS = $(BCMLIB) $(SILO_LIB) -lmpi -lmpi_cxx -lsiloh5
BCMTools_20130417/examples のみに存在: test
BCMTools_20130417/examples のみに存在: util
diff -r BCMTools_20130417/include/BCMTools.h BCMTools_20130709/include/BCMTools.h
20d19
< 
diff -r BCMTools_20130417/include/BlockManager.h BCMTools_20130709/include/BlockManager.h
178a179
>   void printBlockLayoutInfo(const char* filename);
215a217,252
>       U* updater = new U(block->getNeighborInfo());
>       dataClass->setUpdater(updater);
>       int id0 = block->setDataClass(dataClass); 
>       if (it == blockList.begin()) {
>         id = id0;
>       } else {
>         if (id != id0) {
>           std::cout << "error: DataClass register inconsistency" << std::endl;
>           Exit(EX_FAILURE);
>         }
>       }
>     }
>     return id;
>   }
> 
>   /// 仮想セルアップデータUを持つデータクラスDの生成・登録(for contiguous memory access).
>   ///
>   ///  @param[in] vc 仮想セル幅
>   ///
>   template <typename D, typename U, typename T>
>   int setDataClass(int vc) {
>     int id = -1;
>     BlockList::const_iterator it = blockList.begin();
> 		int nb = blockList.size();
>     BlockBase* block = *it;
>     Vec3i size = block->getSize();
>     int nx0 = size[0] + 2*vc;
>     int ny0 = size[1] + 2*vc;
>     int nz0 = size[2] + 2*vc;
> 		T* data = new T[nx0*ny0*nz0*nb];
> 		int n = 0;
>     for (; it != blockList.end(); ++it) {
>       BlockBase* block = *it;
>       Vec3i size = block->getSize();
>       D* dataClass = new D(size, vc, &data[nx0*ny0*nz0*n]);
> 			n++;
diff -r BCMTools_20130417/include/Scalar3D.h BCMTools_20130709/include/Scalar3D.h
52a53,69
>   /// コンストラクタ(for contiguous memory access).
>   ///
>   ///  @param[in] size 分割数
>   ///  @param[in] vc 仮想セル幅
>   ///
>   Scalar3D(const ::Vec3i& size, int vc, T* data0) : UpdatableDataClass(size, vc), index(size, vc) {
>     nx0 = size[0] + 2*vc;
>     ny0 = size[1] + 2*vc;
>     nz0 = size[2] + 2*vc;
>     data = data0;
> 		vc0 = vc;
> 
>     c_j = nx0;
>     c_k = nx0 * ny0;
>     c_0 = (1 + nx0 + nx0 * ny0) * vc;
>   }
> 
diff -r BCMTools_20130417/include/Vec3.h BCMTools_20130709/include/Vec3.h
126c126
< inline std::ostream& operator<<(std::ostream& os, const Vec3<T>& v) {
---
> inline std::ostream& operator<<(std::ostream& os, const ::Vec3<T>& v) {
131c131
< inline std::istream& operator>>(std::istream& is, Vec3<T>& v) {
---
> inline std::istream& operator>>(std::istream& is, ::Vec3<T>& v) {
137c137
< typedef Vec3<int> Vec3i;
---
> typedef ::Vec3<int> Vec3i;
140c140
< typedef Vec3<double> Vec3r;
---
> typedef ::Vec3<double> Vec3r;
BCMTools_20130709/lib のみに存在: libbcm.a
BCMTools_20130417 のみに存在: make_setting.fx
BCMTools_20130417 のみに存在: make_setting.gnu
BCMTools_20130417 のみに存在: make_setting.ibm
BCMTools_20130417 のみに存在: make_setting.intel
diff -r BCMTools_20130417/src/Block/BlockManager.cpp BCMTools_20130709/src/Block/BlockManager.cpp
7a8
> #include <fstream>
106c107
<     std::cout << std::endl << "Block Layout Information" << std::endl;
---
>     std::cout << "Block Layout Information" << std::endl;
270a272,451
> /// ブロック配置情報を出力(ファイル).
> void BlockManager::printBlockLayoutInfo(const char* filename)
> {
>   int myrank = comm.Get_rank();
>   int nprocs = comm.Get_size();
> 
> 	std::ofstream ofs;
>   if (myrank == 0) {
> 		ofs.open(filename, std::ios::out);
> 	}
> 
>   if (myrank == 0) {
>     ofs << "Block Layout Information" << std::endl;
>   }
> 
>   // check level of blocks
> 
>   int levelMin = INT_MAX;
>   int levelMax = 0;
>   for (int localID = 0; localID < numBlock; localID++) {
>     int level = blockList[localID]->getLevel();
>     levelMin = std::min(level, levelMin);
>     levelMax = std::max(level, levelMax);
>   }
> 
> //ofs << myrank << ": Lmin=" << levelMin << " Lmax=" << levelMax << std::endl;
>   
>   comm.Allreduce(MPI_IN_PLACE, &levelMin, 1, MPI::INT, MPI::MIN);
>   comm.Allreduce(MPI_IN_PLACE, &levelMax, 1, MPI::INT, MPI::MAX);
> 
>   if (myrank == 0) {
>     ofs << "  Min level: " << levelMin << std::endl;
>     ofs << "  Max level: " << levelMax << std::endl;
>   }
> 
> 
>   // count blocks
> 
>   int nLevel = levelMax - levelMin + 1;
>   int* nBlock = new int[nLevel];
>   for (int i = 0; i < nLevel; i++) nBlock[i] = 0;
> 
>   for (int localID = 0; localID < numBlock; localID++) {
>     BlockBase* block = blockList[localID];
>     int level = block->getLevel();
>     nBlock[level-levelMin]++;
>   }
> 
>   int numBlockSum;
>   comm.Reduce(&numBlock, &numBlockSum, 1, MPI::INT, MPI::SUM, 0);
>   if (myrank == 0) {
>     comm.Reduce(MPI_IN_PLACE, nBlock, nLevel, MPI::INT, MPI::SUM, 0);
>   } else {
>     comm.Reduce(nBlock, nBlock, nLevel, MPI::INT, MPI::SUM, 0);
>   }
> 
>   if (myrank == 0) {
>     ofs << "  Number of blocks" << std::endl;
>     for (int level = levelMin; level <= levelMax; level++) {
>       ofs << "    L=" << level << ": " << nBlock[level-levelMin] << std::endl;
>     }
>     ofs << "    total: " << numBlockSum << std::endl;
>   }
> 
>   delete[] nBlock;
> 
>   int numBlockMin, numBlockMax;
>   comm.Reduce(&numBlock, &numBlockMin, 1, MPI::INT, MPI::MIN, 0);
>   comm.Reduce(&numBlock, &numBlockMax, 1, MPI::INT, MPI::MAX, 0);
>   int numBlock2Sum = numBlock * numBlock;
>   if (myrank == 0) {
>     comm.Reduce(MPI_IN_PLACE, &numBlock2Sum, 1, MPI::INT, MPI::SUM, 0);
>   } else {
>     comm.Reduce(&numBlock2Sum, &numBlock2Sum, 1, MPI::INT, MPI::SUM, 0);
>   }
> 
>   if (myrank == 0) {
>     ofs << "  Number of total blocks / node" << std::endl;
>     double ave = (double)numBlockSum / nprocs;
>     ofs << "    ave: " << ave << std::endl;
>     ofs << "    min: " << numBlockMin << std::endl;
>     ofs << "    max: " << numBlockMax << std::endl;
>     ofs << "     sd: " << sqrt((double)numBlock2Sum/nprocs - ave*ave)<< std::endl;
>   }
> 
> 
>   // count faces
> 
>   int nFaceInter[3] = { 0, 0, 0 };
>   int nFaceIntra[3] = { 0, 0, 0 };
> 
>   for (int localID = 0; localID < numBlock; localID++) {
>     BlockBase* block = blockList[localID];
>     const NeighborInfo* neighborInfo = block->getNeighborInfo();
>     for (int i = 0; i < NUM_FACE; i++) {
>       Face face = Face(i);
>       if (neighborInfo[face].exists()) {
>         int levelDiff = neighborInfo[face].getLevelDifference();
>         if (levelDiff == 0) {
>           if (neighborInfo[face].getRank() == myrank) {
>             nFaceIntra[LD_0]++;
>           } else {
>             nFaceInter[LD_0]++;
>           }
>         }
>         else if (levelDiff == 1) {
>           for (int j = 0; j < NUM_SUBFACE; j++) {
>             Subface subface = Subface(j);
>             if (neighborInfo[face].getRank(subface) == myrank) {
>               nFaceIntra[LD_P1]++;
>             } else {
>               nFaceInter[LD_P1]++;
>             }
>           }
>         }
>         else if (levelDiff == -1) {
>           if (neighborInfo[face].getRank() == myrank) {
>             nFaceIntra[LD_M1]++;
>           } else {
>             nFaceInter[LD_M1]++;
>           }
>         }
>         else {
>           Exit(EX_FAILURE);
>         }
>       }
>     }
>   }
> 
>   int nFaceInterSum[3] = { 0, 0, 0 };
>   int nFaceIntraSum[3] = { 0, 0, 0 };
> 
>   comm.Reduce(nFaceInter, nFaceInterSum, 3, MPI::INT, MPI::SUM, 0);
>   comm.Reduce(nFaceIntra, nFaceIntraSum, 3, MPI::INT, MPI::SUM, 0);
> 
>   if (myrank == 0) {
>     ofs << "  Number of faces" << std::endl;
>     ofs << "    intra-node " << std::endl;
>     ofs << "        dLevel=-1: " << nFaceIntraSum[LD_M1] << std::endl;
>     ofs << "        dLevel= 0: " << nFaceIntraSum[LD_0] << std::endl;
>     ofs << "        dLevel=+1: " << nFaceIntraSum[LD_P1] << std::endl;
>     ofs << "            total: "
>            << nFaceIntraSum[LD_M1] + nFaceIntraSum[LD_0] + nFaceIntraSum[LD_P1] 
>            << std::endl;
>     ofs << "    inter-node " << std::endl;
>     ofs << "        dLevel=-1: " << nFaceInterSum[LD_M1] << std::endl;
>     ofs << "        dLevel= 0: " << nFaceInterSum[LD_0] << std::endl;
>     ofs << "        dLevel=+1: " << nFaceInterSum[LD_P1] << std::endl;
>     ofs << "            total: "
>            << nFaceInterSum[LD_M1] + nFaceInterSum[LD_0] + nFaceInterSum[LD_P1] 
>            << std::endl;
>   }
> 
>   int nFaceInterTotal = nFaceInter[LD_M1] + nFaceInter[LD_0] + nFaceInter[LD_P1];
> 
>   int nFaceInterTotalMin, nFaceInterTotalMax;
>   comm.Reduce(&nFaceInterTotal, &nFaceInterTotalMin, 1, MPI::INT, MPI::MIN, 0);
>   comm.Reduce(&nFaceInterTotal, &nFaceInterTotalMax, 1, MPI::INT, MPI::MAX, 0);
> 
>   int nFaceInterTotal2Sum = nFaceInterTotal * nFaceInterTotal;
>   if (myrank == 0) {
>     comm.Reduce(MPI_IN_PLACE, &nFaceInterTotal2Sum, 1, MPI::INT, MPI::SUM, 0);
>   } else {
>     comm.Reduce(&nFaceInterTotal2Sum, &nFaceInterTotal2Sum, 1, MPI::INT, MPI::SUM, 0);
>   }
> 
>   if (myrank == 0) {
>     ofs << "  Number of total inter-node faces / node" << std::endl;
>     double ave
>       = (double)(nFaceInterSum[LD_M1] + nFaceInterSum[LD_0] + nFaceInterSum[LD_P1]) / nprocs;
>     ofs << "    ave: " << ave << std::endl;
>     ofs << "    min: " << nFaceInterTotalMin << std::endl;
>     ofs << "    max: " << nFaceInterTotalMax << std::endl;
>     ofs << "     sd: " << sqrt((double)nFaceInterTotal2Sum/nprocs - ave*ave) << std::endl;
>   }
> 
> 	if( myrank == 0 ) {
> 		ofs.close();
> 	}
> }
518a700,714
> 	int nf = faceList.size();
> #ifdef _BLOCK_IS_LARGE_
> #else
> #pragma omp parallel for
> #endif
>   for (int n=0; n<nf; n++) {
>     int id = faceList[n].id;
>     Face face = faceList[n].face;
>     Subface subface = faceList[n].subface;
>     UpdatableDataClass* dataClass
>       = dynamic_cast<UpdatableDataClass*>(
>                           blockList[id]->getDataClass(dataClassID));
>     dataClass->copyFromNeighbor(face, subface);
> 	}
> /*
528a725
> */
536a734,753
> 		FaceList faceList = it_map->second;
> 		int nf = faceList.size();
> #ifdef _BLOCK_IS_LARGE_
> #else
> #pragma omp parallel for
> #endif
> 		for(int n=0; n<nf; n++) {
> 			int id = faceList[n].id;
> 			Face face = faceList[n].face;
> 			Subface subface = faceList[n].subface;
> 			UpdatableDataClass* dataClass
> 				= dynamic_cast<UpdatableDataClass*>(
> 														blockList[id]->getDataClass(dataClassID));
>       dataClass->copyToCommBuffer(face, subface);
> 		}
> 	}
> 
> /*
>   FaceListMap::const_iterator it_map = faceListMap.begin();
>   for (; it_map != faceListMap.end(); ++it_map) {
547a765
> */
555a774,793
> 		FaceList faceList = it_map->second;
> 		int nf = faceList.size();
> #ifdef _BLOCK_IS_LARGE_
> #else
> #pragma omp parallel for
> #endif
> 		for(int n=0; n<nf; n++) {
> 			int id = faceList[n].id;
> 			Face face = faceList[n].face;
> 			Subface subface = faceList[n].subface;
> 			UpdatableDataClass* dataClass
> 				= dynamic_cast<UpdatableDataClass*>(
> 														blockList[id]->getDataClass(dataClassID));
>       dataClass->copyFromCommBuffer(face, subface);
> 		}
> 	}
> 
> /*
>   FaceListMap::const_iterator it_map = faceListMap.begin();
>   for (; it_map != faceListMap.end(); ++it_map) {
566a805
> */
BCMTools_20130709/src/Block のみに存在: BlockManager.o
BCMTools_20130709/src/CommBuffer のみに存在: CommBuffer.o
BCMTools_20130709/src/DataClass のみに存在: Scalar3D.o
BCMTools_20130709/src/DataClass のみに存在: Scalar3DUpdater.o
BCMTools_20130709/src/DataClass のみに存在: Vector3D.o
BCMTools_20130709/src/DataClass のみに存在: Vector3DUpdater.o
BCMTools_20130417/src のみに存在: DataClass.list
diff -r BCMTools_20130417/src/Makefile BCMTools_20130709/src/Makefile
1,23c1
< # Default environment
< FFVC=intel
< 
< ### compiler detection
< 
< ifeq ($(FFVC),gnu)
< include ../make_setting.gnu
< endif
< 
< ifeq ($(FFVC),fx)
< include ../make_setting.fx
< endif
< 
< ifeq ($(FFVC),ibm)
< include ../make_setting.ibm
< endif
< 
< ifeq ($(FFVC),intel)
< include ../make_setting.intel
< endif
< 
< #####
< 
---
> include ../Makefile.inc
25a4
> CFLAGS += -I. -I../include 
35,43c14,19
< 
< CFLAGS += -I. -I../include 
< 
< DATACLASS_LIST = ./DataClass.list
< DataClasss/Scalar3D.o: $(DATACLASS_LIST)
< DataClasss/Vector3D.o: $(DATACLASS_LIST)
< DataClasss/Scalar3DUpdater.o: $(DATACLASS_LIST)
< DataClasss/Vector3DUpdater.o: $(DATACLASS_LIST)
< 
---
> #
> #DATACLASS_LIST = ./DataClass.list
> #DataClasss/Scalar3D.o: $(DATACLASS_LIST)
> #DataClasss/Vector3D.o: $(DATACLASS_LIST)
> #DataClasss/Scalar3DUpdater.o: $(DATACLASS_LIST)
> #DataClasss/Vector3DUpdater.o: $(DATACLASS_LIST)
61a38
> 
